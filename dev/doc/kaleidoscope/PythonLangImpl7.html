

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. Chapter 7: Extending the Language: Mutable Variables / SSA construction &mdash; llvmpy 0.8.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.8.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="llvmpy 0.8.2 documentation" href="../../index.html" />
    <link rel="up" title="Kaleidoscope" href="index.html" />
    <link rel="next" title="&lt;no title&gt;" href="PythonLangImpl8.html" />
    <link rel="prev" title="6. Chapter 6: Extending the Language: User-defined Operators" href="PythonLangImpl6.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="PythonLangImpl8.html" title="&lt;no title&gt;"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl6.html" title="6. Chapter 6: Extending the Language: User-defined Operators"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">llvmpy 0.8.2 documentation</a> &raquo;</li>
          <li><a href="../examples.html" >Examples and LLVM Tutorials</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Kaleidoscope</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-7-extending-the-language-mutable-variables-ssa-construction">
<h1>7. Chapter 7: Extending the Language: Mutable Variables / SSA construction<a class="headerlink" href="#chapter-7-extending-the-language-mutable-variables-ssa-construction" title="Permalink to this headline">¶</a></h1>
<p>Written by <a class="reference external" href="mailto:sabre&#37;&#52;&#48;nondot&#46;org">Chris Lattner</a> and <a class="reference external" href="http://max99x.com">Max
Shawabkeh</a></p>
<div class="section" id="introduction-intro">
<h2>7.1. Introduction # {#intro}<a class="headerlink" href="#introduction-intro" title="Permalink to this headline">¶</a></h2>
<p>Welcome to Chapter 7 of the <a class="reference external" href="http://www.llvm.org/docs/tutorial/index.html">Implementing a language with
LLVM</a> tutorial. In
chapters 1 through 6, we&#8217;ve built a very respectable, albeit simple,
<a class="reference external" href="http://en.wikipedia.org/wiki/Functional_programming">functional programming
language</a>. In our
journey, we learned some parsing techniques, how to build and represent
an AST, how to build LLVM IR, and how to optimize the resultant code as
well as JIT compile it.</p>
<p>While Kaleidoscope is interesting as a functional language, the fact
that it is functional makes it &#8220;too easy&#8221; to generate LLVM IR for it. In
particular, a functional language makes it very easy to build LLVM IR
directly in <a class="reference external" href="http://en.wikipedia.org/wiki/Static_single_assignment_form">SSA
form</a>.
Since LLVM requires that the input code be in SSA form, this is a very
nice property and it is often unclear to newcomers how to generate code
for an imperative language with mutable variables.</p>
<p>The short (and happy) summary of this chapter is that there is no need
for your front-end to build SSA form: LLVM provides highly tuned and
well tested support for this, though the way it works is a bit
unexpected for some.</p>
</div>
<div class="section" id="why-is-this-a-hard-problem-why">
<h2>7.2. Why is this a hard problem? # {#why}<a class="headerlink" href="#why-is-this-a-hard-problem-why" title="Permalink to this headline">¶</a></h2>
<p>To understand why mutable variables cause complexities in SSA
construction, consider this extremely simple C example:</p>
<div class="highlight-python"><pre>int G, H; int test(_Bool Condition) { int X; if
(Condition) X = G; else X = H; return X; }</pre>
</div>
<p>In this case, we have the variable &#8220;X&#8221;, whose value depends on the path
executed in the program. Because there are two different possible values
for X before the return instruction, a PHI node is inserted to merge the
two values. The LLVM IR that we want for this example looks like this:</p>
<div class="highlight-llvm"><pre>@G = weak global i32 0 ; type of @G is i32\* @H =
weak global i32 0 ; type of @H is i32\* define i32 @test(i1 %Condition)
{ entry: br i1 %Condition, label %cond_true, label %cond_false
cond_true: %X.0 = load i32\* @G br label %cond_next cond_false: %X.1
= load i32\* @H br label %cond_next cond_next: %X.2 = phi i32 [ %X.1,
%cond_false ], [ %X.0, %cond_true ] ret i32 %X.2 }</pre>
</div>
<p>In this example, the loads from the G and H global variables are
explicit in the LLVM IR, and they live in the then/else branches of the
if statement (cond_true/cond_false). In order to merge the incoming
values, the X.2 phi node in the cond_next block selects the right value
to use based on where control flow is coming from: if control flow comes
from the cond_false block, X.2 gets the value of X.1. Alternatively, if
control flow comes from cond_true, it gets the value of X.0. The intent
of this chapter is not to explain the details of SSA form. For more
information, see one of the many <a class="reference external" href="http://en.wikipedia.org/wiki/Static_single_assignment_form">online
references</a>.</p>
<p>The question for this article is &#8220;who places the phi nodes when lowering
assignments to mutable variables?&#8221;. The issue here is that LLVM
<em>requires</em> that its IR be in SSA form: there is no &#8220;non-ssa&#8221; mode for
it. However, SSA construction requires non-trivial algorithms and data
structures, so it is inconvenient and wasteful for every front-end to
have to reproduce this logic.</p>
</div>
<div class="section" id="memory-in-llvm-memory">
<h2>7.3. Memory in LLVM # {#memory}<a class="headerlink" href="#memory-in-llvm-memory" title="Permalink to this headline">¶</a></h2>
<p>The &#8216;trick&#8217; here is that while LLVM does require all register values to
be in SSA form, it does not require (or permit) memory objects to be in
SSA form. In the example above, note that the loads from G and H are
direct accesses to G and H: they are not renamed or versioned. This
differs from some other compiler systems, which do try to version memory
objects. In LLVM, instead of encoding dataflow analysis of memory into
the LLVM IR, it is handled with <a class="reference external" href="http://www.llvm.org/docs/WritingAnLLVMPass.html">Analysis
Passes</a> which are
computed on demand.</p>
<p>With this in mind, the high-level idea is that we want to make a stack
variable (which lives in memory, because it is on the stack) for each
mutable object in a function. To take advantage of this trick, we need
to talk about how LLVM represents stack variables.</p>
<p>In LLVM, all memory accesses are explicit with load/store instructions,
and it is carefully designed not to have (or need) an &#8220;address-of&#8221;
operator. Notice how the type of the &#64;G/&#64;H global variables is actually
&#8220;i32<em>&#8221; even though the variable is defined as &#8220;i32&#8221;. What this means
is that &#64;G defines</em>space* for an i32 in the global data area, but its
<em>name</em> actually refers to the address for that space. Stack variables
work the same way, except that instead of being declared with global
variable definitions, they are declared with the <a class="reference external" href="http://www.llvm.org/docs/LangRef.html#i_alloca">LLVM alloca
instruction</a>:</p>
<div class="highlight-python"><pre>define i32 @example() { entry: %X = alloca i32 ;
type of %X is i32\ *. ... %tmp = load i32* %X ; load the stack value %X
from the stack. %tmp2 = add i32 %tmp, 1 ; increment it store i32 %tmp2,
i32\* %X ; store it back ...</pre>
</div>
<p>This code shows an example of how you can declare and manipulate a stack
variable in the LLVM IR. Stack memory allocated with the alloca
instruction is fully general: you can pass the address of the stack slot
to functions, you can store it in other variables, etc. In our example
above, we could rewrite the example to use the alloca technique to avoid
using a PHI node:</p>
<div class="highlight-llvm"><pre>@G = weak global i32 0 ; type of @G is i32\* @H =
weak global i32 0 ; type of @H is i32\* define i32 @test(i1 %Condition)
{ entry: %X = alloca i32 ; type of %X is i32\ *. br i1 %Condition, label
%cond_true, label %cond_false cond_true: %X.0 = load i32* @G store
i32 %X.0, i32\* %X ; Update X br label %cond_next cond_false: %X.1 =
load i32\* @H store i32 %X.1, i32\* %X ; Update X br label %cond_next
cond_next: %X.2 = load i32\* %X ; Read X ret i32 %X.2 } {% endhighlight
%}

With this, we have discovered a way to handle arbitrary mutable
variables without the need to create Phi nodes at all:

.. raw:: html

&lt;ol&gt;
&lt;li&gt;

Each mutable variable becomes a stack allocation.

.. raw:: html

&lt;/li&gt;
&lt;li&gt;

Each read of the variable becomes a load from the stack.

.. raw:: html

&lt;/li&gt;
&lt;li&gt;

Each update of the variable becomes a store to the stack.

.. raw:: html

&lt;/li&gt;
&lt;li&gt;

Taking the address of a variable just uses the stack address directly.

.. raw:: html

&lt;/li&gt;
&lt;/ol&gt;

While this solution has solved our immediate problem, it introduced
another one: we have now apparently introduced a lot of stack traffic
for very simple and common operations, a major performance problem.
Fortunately for us, the LLVM optimizer has a highly-tuned optimization
pass named "mem2reg" that handles this case, promoting allocas like this
into SSA registers, inserting Phi nodes as appropriate. If you run this
example through the pass, for example, you'll get:

{% highlight bash %} $ llvm-as &lt; example.ll \| opt -mem2reg \| llvm-dis</pre>
</div>
<div class="highlight-llvm"><pre>@G = weak global i32 0 @H = weak global i32 0
define i32 @test(i1 %Condition) { entry: br i1 %Condition, label
%cond_true, label %cond_false cond_true: %X.0 = load i32\* @G br
label %cond_next cond_false: %X.1 = load i32\* @H br label %cond_next
cond_next: %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true
] ret i32 %X.01 }</pre>
</div>
<p>The mem2reg pass implements the standard &#8220;iterated dominance frontier&#8221;
algorithm for constructing SSA form and has a number of optimizations
that speed up (very common) degenerate cases. The mem2reg optimization
pass is the answer to dealing with mutable variables, and we highly
recommend that you depend on it. Note that mem2reg only works on
variables in certain circumstances:</p>
<ul class="simple">
<li>mem2reg is alloca-driven: it looks for allocas and if it can handle
them, it promotes them. It does not apply to global variables or heap
allocations.</li>
<li>mem2reg only looks for alloca instructions in the entry block of the
function. Being in the entry block guarantees that the alloca is only
executed once, which makes analysis simpler.</li>
<li>mem2reg only promotes allocas whose uses are direct loads and stores.
If the address of the stack object is passed to a function, or if any
funny pointer arithmetic is involved, the alloca will not be
promoted.</li>
<li>mem2reg only works on allocas of <a class="reference external" href="http://www.llvm.org/docs/LangRef.html#t_classifications">first
class</a>
values (such as pointers, scalars and vectors), and only if the array
size of the allocation is 1 (or missing in the .ll file). mem2reg is
not capable of promoting structs or arrays to registers. Note that
the &#8220;scalarrepl&#8221; pass is more powerful and can promote structs,
&#8220;unions&#8221;, and arrays in many cases.</li>
</ul>
<p>All of these properties are easy to satisfy for most imperative
languages, and we&#8217;ll illustrate it below with Kaleidoscope. The final
question you may be asking is: should I bother with this nonsense for my
front-end? Wouldn&#8217;t it be better if I just did SSA construction
directly, avoiding use of the mem2reg optimization pass? In short, we
strongly recommend that you use this technique for building SSA form,
unless there is an extremely good reason not to. Using this technique
is:</p>
<ul class="simple">
<li>Proven and well tested: llvm-gcc and clang both use this technique
for local mutable variables. As such, the most common clients of LLVM
are using this to handle a bulk of their variables. You can be sure
that bugs are found fast and fixed early.</li>
<li>Extremely Fast: mem2reg has a number of special cases that make it
fast in common cases as well as fully general. For example, it has
fast-paths for variables that are only used in a single block,
variables that only have one assignment point, good heuristics to
avoid insertion of unneeded phi nodes, etc.</li>
<li>Needed for debug info generation: <a class="reference external" href="http://www.llvm.org/docs/SourceLevelDebugging.html">Debug information in
LLVM</a> relies on
having the address of the variable exposed so that debug info can be
attached to it. This technique dovetails very naturally with this
style of debug info.</li>
</ul>
<p>If nothing else, this makes it much easier to get your front-end up and
running, and is very simple to implement. Lets extend Kaleidoscope with
mutable variables now!</p>
</div>
<hr class="docutils" />
<div class="section" id="mutable-variables-in-kaleidoscope-kalvars">
<h2>7.4. Mutable Variables in Kaleidoscope # {#kalvars}<a class="headerlink" href="#mutable-variables-in-kaleidoscope-kalvars" title="Permalink to this headline">¶</a></h2>
<p>Now that we know the sort of problem we want to tackle, lets see what
this looks like in the context of our little Kaleidoscope language.
We&#8217;re going to add two features:</p>
<ul class="simple">
<li>The ability to mutate variables with the &#8216;=&#8217; operator.</li>
<li>The ability to define new variables.</li>
</ul>
<p>While the first item is really what this is about, we only have
variables for incoming arguments as well as for induction variables, and
redefining those only goes so far :). Also, the ability to define new
variables is a useful thing regardless of whether you will be mutating
them. Here&#8217;s a motivating example that shows how we could use these:</p>
<div class="highlight-python"><pre># Define ':' for sequencing: as a low-precedence
operator that ignores operands # and just returns the RHS. def binary :
1 (x y) y;

# Recursive fib, we could do this before.
def fib(x) if (x &lt; 3) then 1 else fib(x-1) + fib(x-2)

# Iterative fib.
def fibi(x) var a = 1, b = 1, c in (for i = 3, i &lt; x in c = a + b : a =
b : b = c) : b

# Call it.
fibi(10)</pre>
</div>
<p>In order to mutate variables, we have to change our existing variables
to use the &#8220;alloca trick&#8221;. Once we have that, we&#8217;ll add our new
operator, then extend Kaleidoscope to support new variable definitions.</p>
</div>
<hr class="docutils" />
<div class="section" id="adjusting-existing-variables-for-mutation-adjustments">
<h2>7.5. Adjusting Existing Variables for Mutation # {#adjustments}<a class="headerlink" href="#adjusting-existing-variables-for-mutation-adjustments" title="Permalink to this headline">¶</a></h2>
<p>The symbol table in Kaleidoscope is managed at code generation time by
the <tt class="docutils literal"><span class="pre">g_named_values</span></tt> map. This map currently keeps track of the LLVM
&#8220;Value&#8221; that holds the double value for the named variable. In order to
support mutation, we need to change this slightly, so that it holds the
<em>memory location</em> of the variable in question. Note that this change is
a refactoring: it changes the structure of the code, but does not (by
itself) change the behavior of the compiler. All of these changes are
isolated in the Kaleidoscope code generator.</p>
<p>At this point in Kaleidoscope&#8217;s development, it only supports variables
for two things: incoming arguments to functions and the induction
variable of &#8216;for&#8217; loops. For consistency, we&#8217;ll allow mutation of these
variables in addition to other user-defined variables. This means that
these will both need memory locations.</p>
<p>To start our transformation of Kaleidoscope, we will need to create the
allocas that we will store in <tt class="docutils literal"><span class="pre">g_named_values</span></tt>. We&#8217;ll use a helper
function that ensures that the allocas are created in the entry block of
the function:</p>
<div class="highlight-python"><pre># Creates an alloca instruction in the entry
block of the function. This is used # for mutable variables. def
CreateEntryBlockAlloca(function, var_name): entry =
function.get_entry_basic_block() builder = Builder.new(entry)
builder.position_at_beginning(entry) return
builder.alloca(Type.double(), var_name)</pre>
</div>
<p>This code creates a temporary <tt class="docutils literal"><span class="pre">llvm.core.Builder</span></tt> that is pointing at
the first instruction of the entry block. It then creates an alloca with
the expected name and returns it. Because all values in Kaleidoscope are
doubles, there is no need to pass in a type to use.</p>
<p>With this in place, the first functionality change we want to make is to
variable references. In our new scheme, variables live on the stack, so
code generating a reference to them actually needs to produce a load
from the stack slot:</p>
<div class="highlight-python"><pre>def CodeGen(self): if self.name in
g_named_values: return
g_llvm_builder.load(g_named_values[self.name], self.name) else:
raise RuntimeError('Unknown variable name: ' + self.name) {%
endhighlight %}

As you can see, this is pretty straightforward. Now we need to update
the things that define the variables to set up the alloca. We'll start
with ``ForExpressionNode.CodeGen`` (see the `full code listing &lt;#code&gt;`_
for the unabridged code):

{% highlight python %} def CodeGen(self): function =
g_llvm_builder.basic_block.function

::

# Create an alloca for the variable in the entry block.
alloca = CreateEntryBlockAlloca(function, self.loop_variable)

# Emit the start code first, without 'variable' in scope.
start_value = self.start.CodeGen()

# Store the value into the alloca.
g_llvm_builder.store(start_value, alloca)
...
# Compute the end condition.
end_condition = self.end.CodeGen()

# Reload, increment, and restore the alloca.  This handles the case where
# the body of the loop mutates the variable.
cur_value = g_llvm_builder.load(alloca, self.loop_variable)
next_value = g_llvm_builder.fadd(cur_value, step_value, 'nextvar')
g_llvm_builder.store(next_value, alloca)

# Convert condition to a bool by comparing equal to 0.0.
end_condition_bool = g_llvm_builder.fcmp(
FCMP_ONE, end_condition, Constant.real(Type.double(), 0), 'loopcond')
...</pre>
</div>
<p>This code is virtually identical to the code <a class="reference external" href="PythonLangImpl5.html#forcodegen">before we allowed mutable
variables</a>. The big difference is
that we no longer have to construct a PHI node, and we use load/store to
access the variable as needed.</p>
<p>To support mutable argument variables, we need to also make allocas for
them. The code for this is also pretty simple:</p>
<div class="highlight-python"><pre>class PrototypeNode(object): ... # Create an
alloca for each argument and register the argument in the symbol # table
so that references to it will succeed. def CreateArgumentAllocas(self,
function): for arg_name, arg in zip(self.args, function.args): alloca =
CreateEntryBlockAlloca(function, arg_name) g_llvm_builder.store(arg,
alloca) g_named_values[arg_name] = alloca</pre>
</div>
<p>For each argument, we make an alloca, store the input value to the
function into the alloca, and register the alloca as the memory location
for the argument. This method gets invoked by <tt class="docutils literal"><span class="pre">FunctionNode.CodeGen</span></tt>
right after it sets up the entry block for the function.</p>
<p>The final missing piece is adding the mem2reg pass, which allows us to
get good codegen once again:</p>
<div class="highlight-python"><pre>from llvm.passes import
(PASS_PROMOTE_MEMORY_TO_REGISTER, PASS_INSTRUCTION_COMBINING,
PASS_REASSOCIATE, PASS_GVN, PASS_CFG_SIMPLIFICATION) ... def main():
# Set up the optimizer pipeline. Start with registering info about how
the # target lays out data structures.
g_llvm_pass_manager.add(g_llvm_executor.target_data) # Promote
allocas to registers.
g_llvm_pass_manager.add(PASS_PROMOTE_MEMORY_TO_REGISTER) # Do
simple "peephole" optimizations and bit-twiddling optzns.
g_llvm_pass_manager.add(PASS_INSTRUCTION_COMBINING) # Reassociate
expressions. g_llvm_pass_manager.add(PASS_REASSOCIATE) {%
endhighlight %}

It is interesting to see what the code looks like before and after the
mem2reg optimization runs. For example, this is the before/after code
for our recursive fib function. Before the optimization:

{% highlight llvm %} define double @fib(double %x) { entry: %x1 = alloca
double store double %x, double\* %x1 %x2 = load double\* %x1 %cmptmp =
fcmp ult double %x2, 3.000000e+00 %booltmp = uitofp i1 %cmptmp to double
%ifcond = fcmp one double %booltmp, 0.000000e+00 br i1 %ifcond, label
%then, label %else then: ; preds = %entry br label %ifcont else: ; preds
= %entry %x3 = load double\* %x1 %subtmp = fsub double %x3, 1.000000e+00
%calltmp = call double @fib(double %subtmp) %x4 = load double\* %x1
%subtmp5 = fsub double %x4, 2.000000e+00 %calltmp6 = call double
@fib(double %subtmp5) %addtmp = fadd double %calltmp, %calltmp6 br label
%ifcont ifcont: ; preds = %else, %then %iftmp = phi double [
1.000000e+00, %then ], [ %addtmp, %else ] ret double %iftmp } {%
endhighlight %}

Here there is only one variable (x, the input argument) but you can
still see the extremely simple-minded code generation strategy we are
using. In the entry block, an alloca is created, and the initial input
value is stored into it. Each reference to the variable does a reload
from the stack. Also, note that we didn't modify the if/then/else
expression, so it still inserts a PHI node. While we could make an
alloca for it, it is actually easier to create a PHI node for it, so we
still just make the PHI.

Here is the code after the mem2reg pass runs:

{% highlight llvm %} define double @fib(double %x) { entry: %cmptmp =
fcmp ult double %x, 3.000000e+00 %booltmp = uitofp i1 %cmptmp to double
%ifcond = fcmp one double %booltmp, 0.000000e+00 br i1 %ifcond, label
%then, label %else then: br label %ifcont else: %subtmp = fsub double
%x, 1.000000e+00 %calltmp = call double @fib(double %subtmp) %subtmp5 =
fsub double %x, 2.000000e+00 %calltmp6 = call double @fib(double
%subtmp5) %addtmp = fadd double %calltmp, %calltmp6 br label %ifcont
ifcont: ; preds = %else, %then %iftmp = phi double [ 1.000000e+00, %then
], [ %addtmp, %else ] ret double %iftmp }</pre>
</div>
<p>This is a trivial case for mem2reg, since there are no redefinitions of
the variable. The point of showing this is to calm your tension about
inserting such blatent inefficiencies :).</p>
<p>After the rest of the optimizers run, we get:</p>
<div class="highlight-llvm"><pre>define double @fib(double %x) { entry: %cmptmp =
fcmp ult double %x, 3.000000e+00 %booltmp = uitofp i1 %cmptmp to double
%ifcond = fcmp ueq double %booltmp, 0.000000e+00 br i1 %ifcond, label
%else, label %ifcont else: %subtmp = fsub double %x, 1.000000e+00
%calltmp = call double @fib(double %subtmp) %subtmp5 = fsub double %x,
2.000000e+00 %calltmp6 = call double @fib(double %subtmp5) %addtmp =
fadd double %calltmp, %calltmp6 ret double %addtmp ifcont: ret double
1.000000e+00 }</pre>
</div>
<p>Here we see that the simplifycfg pass decided to clone the return
instruction into the end of the &#8216;else&#8217; block. This allowed it to
eliminate some branches and the PHI node.</p>
<p>Now that all symbol table references are updated to use stack variables,
we&#8217;ll add the assignment operator.</p>
</div>
<hr class="docutils" />
<div class="section" id="new-assignment-operator-assignment">
<h2>7.6. New Assignment Operator # {#assignment}<a class="headerlink" href="#new-assignment-operator-assignment" title="Permalink to this headline">¶</a></h2>
<p>With our current framework, adding a new assignment operator is really
simple. We will parse it just like any other binary operator, but handle
it internally (instead of allowing the user to define it). The first
step is to set a precedence:</p>
<div class="highlight-python"><pre>def main(): ... # Install standard binary
operators. # 1 is lowest possible precedence. 40 is the highest.
g_binop_precedence['='] = 2 g_binop_precedence['&lt;'] = 10
g_binop_precedence['+'] = 20 g_binop_precedence['-'] = 20 {%
endhighlight %}

Now that the parser knows the precedence of the binary operator, it
takes care of all the parsing and AST generation. We just need to
implement codegen for the assignment operator. This looks like:

{% highlight python %} class
BinaryOperatorExpressionNode(ExpressionNode): ... def CodeGen(self): # A
special case for '=' because we don't want to emit the LHS as an #
expression. if self.operator == '=': # Assignment requires the LHS to be
an identifier. if not isinstance(self.left, VariableExpressionNode):
raise RuntimeError('Destination of "=" must be a variable.') {%
endhighlight %}

Unlike the rest of the binary operators, our assignment operator doesn't
follow the "emit LHS, emit RHS, do computation" model. As such, it is
handled as a special case before the other binary operators are handled.
The other strange thing is that it requires the LHS to be a variable. It
is invalid to have ``(x+1) = expr`` -- only things like ``x = expr`` are
allowed.

{% highlight python %} # Codegen the RHS. value = self.right.CodeGen()

::

# Look up the name.
variable = g_named_values[self.left.name]

# Store the value and return it.
g_llvm_builder.store(value, variable)

return value
...</pre>
</div>
<p>Once we have the variable, CodeGening the assignment is straightforward:
we emit the RHS of the assignment, create a store, and return the
computed value. Returning a value allows for chained assignments like
<tt class="docutils literal"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">(Y</span> <span class="pre">=</span> <span class="pre">Z)</span></tt>.</p>
<p>Now that we have an assignment operator, we can mutate loop variables
and arguments. For example, we can now run code like this:</p>
<div class="highlight-python"><pre># Function to print a double. extern printd(x)

# Define ':' for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
def binary : 1 (x y) y

def test(x) printd(x) : x = 4 : printd(x)

test(123)</pre>
</div>
<p>When run, this example prints &#8220;123&#8221; and then &#8220;4&#8221;, showing that we did
actually mutate the value! Okay, we have now officially implemented our
goal: getting this to work requires SSA construction in the general
case. However, to be really useful, we want the ability to define our
own local variables. Let&#8217;s add this next!</p>
</div>
<hr class="docutils" />
<div class="section" id="user-defined-local-variables-localvars">
<h2>7.7. User-defined Local Variables # {#localvars}<a class="headerlink" href="#user-defined-local-variables-localvars" title="Permalink to this headline">¶</a></h2>
<p>Adding var/in is just like any other other extensions we made to
Kaleidoscope: we extend the lexer, the parser, the AST and the code
generator. The first step for adding our new &#8216;var/in&#8217; construct is to
extend the lexer. As before, this is pretty trivial, the code looks like
this:</p>
<div class="highlight-python"><pre>... class UnaryToken(object): pass class
VarToken(object): pass ... def Tokenize(string): ... elif identifier ==
'unary': yield UnaryToken() elif identifier == 'var': yield VarToken()
else: yield IdentifierToken(identifier)</pre>
</div>
<p>The next step is to define the AST node that we will construct. For
var/in, it looks like this:</p>
<div class="highlight-python"><pre># Expression class for var/in. class
VarExpressionNode(ExpressionNode):

def **init**\ (self, variables, body): self.variables = variables
self.body = body

def CodeGen(self): ...</pre>
</div>
<p>var/in allows a list of names to be defined all at once, and each name
can optionally have an initializer value. As such, we capture this
information in the variables list. Also, var/in has a body, this body is
allowed to access the variables defined by the var/in.</p>
<p>With this in place, we can define the parser pieces. The first thing we
do is add it as a primary expression:</p>
<div class="highlight-python"><pre># primary ::= # dentifierexpr \| numberexpr \|
parenexpr \| ifexpr \| forexpr \| varexpr def ParsePrimary(self): if
isinstance(self.current, IdentifierToken): return
self.ParseIdentifierExpr() elif isinstance(self.current, NumberToken):
return self.ParseNumberExpr() elif isinstance(self.current, IfToken):
return self.ParseIfExpr() elif isinstance(self.current, ForToken):
return self.ParseForExpr() elif isinstance(self.current, VarToken):
return self.ParseVarExpr() elif self.current == CharacterToken('('):
return self.ParseParenExpr() else: raise RuntimeError('Unknown token
when expecting an expression.')</pre>
</div>
<p>Next we define ParseVarExpr:</p>
<div class="highlight-python"><pre># varexpr ::= 'var' (identifier ('='
expression)?)+ 'in' expression def ParseVarExpr(self): self.Next() # eat
'var'.

::

variables = {}

# At least one variable name is required.
if not isinstance(self.current, IdentifierToken):
raise RuntimeError('Expected identifier after "var".')</pre>
</div>
<p>The first part of this code parses the list of identifier/expr pairs
into the local <tt class="docutils literal"><span class="pre">variables</span></tt> list.</p>
<div class="highlight-python"><pre>while True: var_name = self.current.name
self.Next() # eat the identifier.

::

# Read the optional initializer.
if self.current == CharacterToken('='):
self.Next()  # eat '='.
variables[var_name] = self.ParseExpression()
else:
variables[var_name] = None

# End of var list, exit loop.
if self.current != CharacterToken(','):
break
self.Next()  # eat ','.

if not isinstance(self.current, IdentifierToken):
raise RuntimeError('Expected identifier after "," in a var expression.')</pre>
</div>
<p>Once all the variables are parsed, we then parse the body and create the
AST node:</p>
<div class="highlight-python"><pre># At this point, we have to have 'in'. if not
isinstance(self.current, InToken): raise RuntimeError('Expected "in"
keyword after "var".') self.Next() # eat 'in'.

::

body = self.ParseExpression()

return VarExpressionNode(variables, body)</pre>
</div>
<p>Now that we can parse and represent the code, we need to support
emission of LLVM IR for it. This code starts out with:</p>
<div class="highlight-python"><pre>class VarExpressionNode(ExpressionNode): ... def
CodeGen(self): old_bindings = {} function =
g_llvm_builder.basic_block.function

::

# Register all variables and emit their initializer.
for var_name, var_expression in self.variables.iteritems():
# Emit the initializer before adding the variable to scope, this prevents
# the initializer from referencing the variable itself, and permits stuff
# like this:
#  var a = 1 in
#    var a = a in ...   # refers to outer 'a'.
if var_expression is not None:
var_value = var_expression.CodeGen()
else:
var_value = Constant.real(Type.double(), 0)

alloca = CreateEntryBlockAlloca(function, var_name)
g_llvm_builder.store(var_value, alloca)

# Remember the old variable binding so that we can restore the binding
# when we unrecurse.
old_bindings[var_name] = g_named_values.get(var_name, None)

# Remember this binding.
g_named_values[var_name] = alloca</pre>
</div>
<p>Basically it loops over all the variables, installing them one at a
time. For each variable we put into the symbol table, we remember the
previous value that we replace in <tt class="docutils literal"><span class="pre">old_bindings</span></tt>.</p>
<p>There are more comments here than code. The basic idea is that we emit
the initializer, create the alloca, then update the symbol table to
point to it. Once all the variables are installed in the symbol table,
we evaluate the body of the var/in expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Codegen the body, now that all vars are in</span>
<span class="n">scope</span><span class="o">.</span> <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally, before returning, we restore the previous variable bindings:</p>
<div class="highlight-python"><pre># Pop all our variables from scope. for var_name
in self.variables: if old_bindings[var_name] is not None:
g_named_values[var_name] = old_bindings[var_name] else: del
g_named_values[var_name]

::

# Return the body computation.
return body</pre>
</div>
<p>The end result of all of this is that we get properly scoped variable
definitions, and we even (trivially) allow mutation of them :).</p>
<p>With this, we completed what we set out to do. Our nice iterative fib
example from the intro compiles and runs just fine. The mem2reg pass
optimizes all of our stack variables into SSA registers, inserting PHI
nodes where needed, and our front-end remains simple: no &#8220;iterated
dominance frontier&#8221; computation anywhere in sight.</p>
</div>
<hr class="docutils" />
<div class="section" id="full-code-listing-code">
<h2>7.8. Full Code Listing # {#code}<a class="headerlink" href="#full-code-listing-code" title="Permalink to this headline">¶</a></h2>
<p>Here is the complete code listing for our running example, enhanced with
mutable variables and var/in support:</p>
<div class="highlight-python"><pre>#!/usr/bin/env python

import re from llvm.core import Module, Constant, Type, Function,
Builder from llvm.ee import ExecutionEngine, TargetData from llvm.passes
import FunctionPassManager

from llvm.core import FCMP_ULT, FCMP_ONE from llvm.passes import
(PASS_PROMOTE_MEMORY_TO_REGISTER, PASS_INSTRUCTION_COMBINING,
PASS_REASSOCIATE, PASS_GVN, PASS_CFG_SIMPLIFICATION)

Globals
-------

# The LLVM module, which holds all the IR code.
g_llvm_module = Module.new('my cool jit')

# The LLVM instruction builder. Created whenever a new function is entered.
g_llvm_builder = None

# A dictionary that keeps track of which values are defined in the current scope
# and what their LLVM representation is.
g_named_values = {}

# The function optimization passes manager.
g_llvm_pass_manager = FunctionPassManager.new(g_llvm_module)

# The LLVM execution engine.
g_llvm_executor = ExecutionEngine.new(g_llvm_module)

# The binary operator precedence chart.
g_binop_precedence = {}

# Creates an alloca instruction in the entry block of the function. This is used
# for mutable variables.
def CreateEntryBlockAlloca(function, var_name): entry =
function.get_entry_basic_block() builder = Builder.new(entry)
builder.position_at_beginning(entry) return
builder.alloca(Type.double(), var_name)

Lexer
-----

# The lexer yields one of these types for each token.
class EOFToken(object): pass class DefToken(object): pass class
ExternToken(object): pass class IfToken(object): pass class
ThenToken(object): pass class ElseToken(object): pass class
ForToken(object): pass class InToken(object): pass class
BinaryToken(object): pass class UnaryToken(object): pass class
VarToken(object): pass

class IdentifierToken(object): def **init**\ (self, name): self.name =
name

class NumberToken(object): def **init**\ (self, value): self.value =
value

class CharacterToken(object): def **init**\ (self, char): self.char =
char def **eq**\ (self, other): return isinstance(other, CharacterToken)
and self.char == other.char def **ne**\ (self, other): return not self
== other

# Regular expressions that tokens and comments of our language.
REGEX_NUMBER = re.compile('[0-9]+(?:.[0-9]+)?') REGEX_IDENTIFIER =
re.compile('[a-zA-Z][a-zA-Z0-9]\ *') REGEX_COMMENT = re.compile('#.*')

def Tokenize(string): while string: # Skip whitespace. if
string[0].isspace(): string = string[1:] continue

::

# Run regexes.
comment_match = REGEX_COMMENT.match(string)
number_match = REGEX_NUMBER.match(string)
identifier_match = REGEX_IDENTIFIER.match(string)

# Check if any of the regexes matched and yield the appropriate result.
if comment_match:
comment = comment_match.group(0)
string = string[len(comment):]
elif number_match:
number = number_match.group(0)
yield NumberToken(float(number))
string = string[len(number):]
elif identifier_match:
identifier = identifier_match.group(0)
# Check if we matched a keyword.
if identifier == 'def':
yield DefToken()
elif identifier == 'extern':
yield ExternToken()
elif identifier == 'if':
yield IfToken()
elif identifier == 'then':
yield ThenToken()
elif identifier == 'else':
yield ElseToken()
elif identifier == 'for':
yield ForToken()
elif identifier == 'in':
yield InToken()
elif identifier == 'binary':
yield BinaryToken()
elif identifier == 'unary':
yield UnaryToken()
elif identifier == 'var':
yield VarToken()
else:
yield IdentifierToken(identifier)
string = string[len(identifier):]
else:
# Yield the ASCII value of the unknown character.
yield CharacterToken(string[0])
string = string[1:]

yield EOFToken()

Abstract Syntax Tree (aka Parse Tree)
-------------------------------------

# Base class for all expression nodes.
class ExpressionNode(object): pass

# Expression class for numeric literals like "1.0".
class NumberExpressionNode(ExpressionNode):

def **init**\ (self, value): self.value = value

def CodeGen(self): return Constant.real(Type.double(), self.value)

# Expression class for referencing a variable, like "a".
class VariableExpressionNode(ExpressionNode):

def **init**\ (self, name): self.name = name

def CodeGen(self): if self.name in g_named_values: return
g_llvm_builder.load(g_named_values[self.name], self.name) else:
raise RuntimeError('Unknown variable name: ' + self.name)

# Expression class for a binary operator.
class BinaryOperatorExpressionNode(ExpressionNode):

def **init**\ (self, operator, left, right): self.operator = operator
self.left = left self.right = right

def CodeGen(self): # A special case for '=' because we don't want to
emit the LHS as an # expression. if self.operator == '=': # Assignment
requires the LHS to be an identifier. if not isinstance(self.left,
VariableExpressionNode): raise RuntimeError('Destination of "=" must be
a variable.')

::

# Codegen the RHS.
value = self.right.CodeGen()

# Look up the name.
variable = g_named_values[self.left.name]

# Store the value and return it.
g_llvm_builder.store(value, variable)

return value

left = self.left.CodeGen()
right = self.right.CodeGen()

if self.operator == '+':
return g_llvm_builder.fadd(left, right, 'addtmp')
elif self.operator == '-':
return g_llvm_builder.fsub(left, right, 'subtmp')
elif self.operator == '*':
return g_llvm_builder.fmul(left, right, 'multmp')
elif self.operator == '&lt;':
result = g_llvm_builder.fcmp(FCMP_ULT, left, right, 'cmptmp')
# Convert bool 0 or 1 to double 0.0 or 1.0.
return g_llvm_builder.uitofp(result, Type.double(), 'booltmp')
else:
function = g_llvm_module.get_function_named('binary' + self.operator)
return g_llvm_builder.call(function, [left, right], 'binop')

# Expression class for function calls.
class CallExpressionNode(ExpressionNode):

def **init**\ (self, callee, args): self.callee = callee self.args =
args

def CodeGen(self): # Look up the name in the global module table. callee
= g_llvm_module.get_function_named(self.callee)

::

# Check for argument mismatch error.
if len(callee.args) != len(self.args):
raise RuntimeError('Incorrect number of arguments passed.')

arg_values = [i.CodeGen() for i in self.args]

return g_llvm_builder.call(callee, arg_values, 'calltmp')

# Expression class for if/then/else.
class IfExpressionNode(ExpressionNode):

def **init**\ (self, condition, then_branch, else_branch):
self.condition = condition self.then_branch = then_branch
self.else_branch = else_branch

def CodeGen(self): condition = self.condition.CodeGen()

::

# Convert condition to a bool by comparing equal to 0.0.
condition_bool = g_llvm_builder.fcmp(
FCMP_ONE, condition, Constant.real(Type.double(), 0), 'ifcond')

function = g_llvm_builder.basic_block.function

# Create blocks for the then and else cases. Insert the 'then' block at the
# end of the function.
then_block = function.append_basic_block('then')
else_block = function.append_basic_block('else')
merge_block = function.append_basic_block('ifcond')

g_llvm_builder.cbranch(condition_bool, then_block, else_block)

# Emit then value.
g_llvm_builder.position_at_end(then_block)
then_value = self.then_branch.CodeGen()
g_llvm_builder.branch(merge_block)

# Codegen of 'Then' can change the current block; update then_block for the
# PHI node.
then_block = g_llvm_builder.basic_block

# Emit else block.
g_llvm_builder.position_at_end(else_block)
else_value = self.else_branch.CodeGen()
g_llvm_builder.branch(merge_block)

# Codegen of 'Else' can change the current block, update else_block for the
# PHI node.
else_block = g_llvm_builder.basic_block

# Emit merge block.
g_llvm_builder.position_at_end(merge_block)
phi = g_llvm_builder.phi(Type.double(), 'iftmp')
phi.add_incoming(then_value, then_block)
phi.add_incoming(else_value, else_block)

return phi

# Expression class for for/in.
class ForExpressionNode(ExpressionNode):

def **init**\ (self, loop_variable, start, end, step, body):
self.loop_variable = loop_variable self.start = start self.end = end
self.step = step self.body = body

def CodeGen(self): # Output this as: # var = alloca double # ... # start
= startexpr # store start -&gt; var # goto loop # loop: # ... # bodyexpr #
... # loopend: # step = stepexpr # endcond = endexpr # # curvar = load
var # nextvar = curvar + step # store nextvar -&gt; var # br endcond, loop,
endloop # outloop:

::

function = g_llvm_builder.basic_block.function

# Create an alloca for the variable in the entry block.
alloca = CreateEntryBlockAlloca(function, self.loop_variable)

# Emit the start code first, without 'variable' in scope.
start_value = self.start.CodeGen()

# Store the value into the alloca.
g_llvm_builder.store(start_value, alloca)

# Make the new basic block for the loop, inserting after current block.
loop_block = function.append_basic_block('loop')

# Insert an explicit fall through from the current block to the loop_block.
g_llvm_builder.branch(loop_block)

# Start insertion in loop_block.
g_llvm_builder.position_at_end(loop_block)

# Within the loop, the variable is defined equal to the alloca.  If it
# shadows an existing variable, we have to restore it, so save it now.
old_value = g_named_values.get(self.loop_variable, None)
g_named_values[self.loop_variable] = alloca

# Emit the body of the loop.  This, like any other expr, can change the
# current BB.  Note that we ignore the value computed by the body.
self.body.CodeGen()

# Emit the step value.
if self.step:
step_value = self.step.CodeGen()
else:
# If not specified, use 1.0.
step_value = Constant.real(Type.double(), 1)

# Compute the end condition.
end_condition = self.end.CodeGen()

# Reload, increment, and restore the alloca.  This handles the case where
# the body of the loop mutates the variable.
cur_value = g_llvm_builder.load(alloca, self.loop_variable)
next_value = g_llvm_builder.fadd(cur_value, step_value, 'nextvar')
g_llvm_builder.store(next_value, alloca)

# Convert condition to a bool by comparing equal to 0.0.
end_condition_bool = g_llvm_builder.fcmp(
FCMP_ONE, end_condition, Constant.real(Type.double(), 0), 'loopcond')

# Create the "after loop" block and insert it.
after_block = function.append_basic_block('afterloop')

# Insert the conditional branch into the end of loop_block.
g_llvm_builder.cbranch(end_condition_bool, loop_block, after_block)

# Any new code will be inserted in after_block.
g_llvm_builder.position_at_end(after_block)

# Restore the unshadowed variable.
if old_value is not None:
g_named_values[self.loop_variable] = old_value
else:
del g_named_values[self.loop_variable]

# for expr always returns 0.0.
return Constant.real(Type.double(), 0)

# Expression class for a unary operator.
class UnaryExpressionNode(ExpressionNode):

def **init**\ (self, operator, operand): self.operator = operator
self.operand = operand

def CodeGen(self): operand = self.operand.CodeGen() function =
g_llvm_module.get_function_named('unary' + self.operator) return
g_llvm_builder.call(function, [operand], 'unop')

# Expression class for var/in.
class VarExpressionNode(ExpressionNode):

def **init**\ (self, variables, body): self.variables = variables
self.body = body

def CodeGen(self): old_bindings = {} function =
g_llvm_builder.basic_block.function

::

# Register all variables and emit their initializer.
for var_name, var_expression in self.variables.iteritems():
# Emit the initializer before adding the variable to scope, this prevents
# the initializer from referencing the variable itself, and permits stuff
# like this:
#  var a = 1 in
#    var a = a in ...   # refers to outer 'a'.
if var_expression is not None:
var_value = var_expression.CodeGen()
else:
var_value = Constant.real(Type.double(), 0)

alloca = CreateEntryBlockAlloca(function, var_name)
g_llvm_builder.store(var_value, alloca)

# Remember the old variable binding so that we can restore the binding
# when we unrecurse.
old_bindings[var_name] = g_named_values.get(var_name, None)

# Remember this binding.
g_named_values[var_name] = alloca

# Codegen the body, now that all vars are in scope.
body = self.body.CodeGen()

# Pop all our variables from scope.
for var_name in self.variables:
if old_bindings[var_name] is not None:
g_named_values[var_name] = old_bindings[var_name]
else:
del g_named_values[var_name]

# Return the body computation.
return body

# This class represents the "prototype" for a function, which captures its name,
# and its argument names (thus implicitly the number of arguments the function
# takes), as well as if it is an operator.
class PrototypeNode(object):

def **init**\ (self, name, args, is_operator=False, precedence=0):
self.name = name self.args = args self.is_operator = is_operator
self.precedence = precedence

def IsBinaryOp(self): return self.is_operator and len(self.args) == 2

def GetOperatorName(self): assert self.is_operator return self.name[-1]

def CodeGen(self): # Make the function type, eg. double(double,double).
funct_type = Type.function( Type.double(), [Type.double()] \*
len(self.args), False)

::

function = Function.new(g_llvm_module, funct_type, self.name)

# If the name conflicted, there was already something with the same name.
# If it has a body, don't allow redefinition or reextern.
if function.name != self.name:
function.delete()
function = g_llvm_module.get_function_named(self.name)

# If the function already has a body, reject this.
if not function.is_declaration:
raise RuntimeError('Redefinition of function.')

# If the function took a different number of args, reject.
if len(function.args) != len(self.args):
raise RuntimeError('Redeclaration of a function with different number '
'of args.')

# Set names for all arguments and add them to the variables symbol table.
for arg, arg_name in zip(function.args, self.args):
arg.name = arg_name

return function

# Create an alloca for each argument and register the argument in the
symbol # table so that references to it will succeed. def
CreateArgumentAllocas(self, function): for arg_name, arg in
zip(self.args, function.args): alloca = CreateEntryBlockAlloca(function,
arg_name) g_llvm_builder.store(arg, alloca)
g_named_values[arg_name] = alloca

# This class represents a function definition itself.
class FunctionNode(object):

def **init**\ (self, prototype, body): self.prototype = prototype
self.body = body

def CodeGen(self): # Clear scope. g_named_values.clear()

::

# Create a function object.
function = self.prototype.CodeGen()

# If this is a binary operator, install its precedence.
if self.prototype.IsBinaryOp():
operator = self.prototype.GetOperatorName()
g_binop_precedence[operator] = self.prototype.precedence

# Create a new basic block to start insertion into.
block = function.append_basic_block('entry')
global g_llvm_builder
g_llvm_builder = Builder.new(block)

# Add all arguments to the symbol table and create their allocas.
self.prototype.CreateArgumentAllocas(function)

# Finish off the function.
try:
return_value = self.body.CodeGen()
g_llvm_builder.ret(return_value)

# Validate the generated code, checking for consistency.
function.verify()

# Optimize the function.
g_llvm_pass_manager.run(function)
except:
function.delete()
if self.prototype.IsBinaryOp():
del g_binop_precedence[self.prototype.GetOperatorName()]
raise

return function

Parser
------

class Parser(object):

def **init**\ (self, tokens): self.tokens = tokens self.Next()

# Provide a simple token buffer. Parser.current is the current token the
# parser is looking at. Parser.Next() reads another token from the lexer
and # updates Parser.current with its results. def Next(self):
self.current = self.tokens.next()

# Gets the precedence of the current token, or -1 if the token is not a
binary # operator. def GetCurrentTokenPrecedence(self): if
isinstance(self.current, CharacterToken): return
g_binop_precedence.get(self.current.char, -1) else: return -1

# identifierexpr ::= identifier \| identifier '(' expression\* ')' def
ParseIdentifierExpr(self): identifier_name = self.current.name
self.Next() # eat identifier.

::

if self.current != CharacterToken('('):  # Simple variable reference.
return VariableExpressionNode(identifier_name)

# Call.
self.Next()  # eat '('.
args = []
if self.current != CharacterToken(')'):
while True:
args.append(self.ParseExpression())
if self.current == CharacterToken(')'):
break
elif self.current != CharacterToken(','):
raise RuntimeError('Expected ")" or "," in argument list.')
self.Next()

self.Next()  # eat ')'.
return CallExpressionNode(identifier_name, args)

# numberexpr ::= number def ParseNumberExpr(self): result =
NumberExpressionNode(self.current.value) self.Next() # consume the
number. return result

# parenexpr ::= '(' expression ')' def ParseParenExpr(self): self.Next()
# eat '('.

::

contents = self.ParseExpression()

if self.current != CharacterToken(')'):
raise RuntimeError('Expected ")".')
self.Next()  # eat ')'.

return contents

# ifexpr ::= 'if' expression 'then' expression 'else' expression def
ParseIfExpr(self): self.Next() # eat the if.

::

# condition.
condition = self.ParseExpression()

if not isinstance(self.current, ThenToken):
raise RuntimeError('Expected "then".')
self.Next()  # eat the then.

then_branch = self.ParseExpression()

if not isinstance(self.current, ElseToken):
raise RuntimeError('Expected "else".')
self.Next()  # eat the else.

else_branch = self.ParseExpression()

return IfExpressionNode(condition, then_branch, else_branch)

# forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in'
expression def ParseForExpr(self): self.Next() # eat the for.

::

if not isinstance(self.current, IdentifierToken):
raise RuntimeError('Expected identifier after for.')

loop_variable = self.current.name
self.Next()  # eat the identifier.

if self.current != CharacterToken('='):
raise RuntimeError('Expected "=" after for variable.')
self.Next()  # eat the '='.

start = self.ParseExpression()

if self.current != CharacterToken(','):
raise RuntimeError('Expected "," after for start value.')
self.Next()  # eat the ','.

end = self.ParseExpression()

# The step value is optional.
if self.current == CharacterToken(','):
self.Next()  # eat the ','.
step = self.ParseExpression()
else:
step = None

if not isinstance(self.current, InToken):
raise RuntimeError('Expected "in" after for variable specification.')
self.Next()  # eat 'in'.

body = self.ParseExpression()

return ForExpressionNode(loop_variable, start, end, step, body)

# varexpr ::= 'var' (identifier ('=' expression)?)+ 'in' expression def
ParseVarExpr(self): self.Next() # eat 'var'.

::

variables = {}

# At least one variable name is required.
if not isinstance(self.current, IdentifierToken):
raise RuntimeError('Expected identifier after "var".')

while True:
var_name = self.current.name
self.Next()  # eat the identifier.

# Read the optional initializer.
if self.current == CharacterToken('='):
self.Next()  # eat '='.
variables[var_name] = self.ParseExpression()
else:
variables[var_name] = None

# End of var list, exit loop.
if self.current != CharacterToken(','):
break
self.Next()  # eat ','.

if not isinstance(self.current, IdentifierToken):
raise RuntimeError('Expected identifier after "," in a var expression.')

# At this point, we have to have 'in'.
if not isinstance(self.current, InToken):
raise RuntimeError('Expected "in" keyword after "var".')
self.Next()  # eat 'in'.

body = self.ParseExpression()

return VarExpressionNode(variables, body)

# primary ::= # dentifierexpr \| numberexpr \| parenexpr \| ifexpr \|
forexpr \| varexpr def ParsePrimary(self): if isinstance(self.current,
IdentifierToken): return self.ParseIdentifierExpr() elif
isinstance(self.current, NumberToken): return self.ParseNumberExpr()
elif isinstance(self.current, IfToken): return self.ParseIfExpr() elif
isinstance(self.current, ForToken): return self.ParseForExpr() elif
isinstance(self.current, VarToken): return self.ParseVarExpr() elif
self.current == CharacterToken('('): return self.ParseParenExpr() else:
raise RuntimeError('Unknown token when expecting an expression.')

# unary ::= primary \| unary_operator unary def ParseUnary(self): # If
the current token is not an operator, it must be a primary expression.
if (not isinstance(self.current, CharacterToken) or self.current in
[CharacterToken('('), CharacterToken(',')]): return self.ParsePrimary()

::

# If this is a unary operator, read it.
operator = self.current.char
self.Next()  # eat the operator.
return UnaryExpressionNode(operator, self.ParseUnary())

# binoprhs ::= (binary_operator unary)\* def ParseBinOpRHS(self, left,
left_precedence): # If this is a binary operator, find its precedence.
while True: precedence = self.GetCurrentTokenPrecedence()

::

# If this is a binary operator that binds at least as tightly as the
# current one, consume it; otherwise we are done.
if precedence &lt; left_precedence:
return left

binary_operator = self.current.char
self.Next()  # eat the operator.

# Parse the unary expression after the binary operator.
right = self.ParseUnary()

# If binary_operator binds less tightly with right than the operator after
# right, let the pending operator take right as its left.
next_precedence = self.GetCurrentTokenPrecedence()
if precedence &lt; next_precedence:
right = self.ParseBinOpRHS(right, precedence + 1)

# Merge left/right.
left = BinaryOperatorExpressionNode(binary_operator, left, right)

# expression ::= unary binoprhs def ParseExpression(self): left =
self.ParseUnary() return self.ParseBinOpRHS(left, 0)

# prototype # ::= id '(' id\* ')' # ::= binary LETTER number? (id, id) #
::= unary LETTER (id) def ParsePrototype(self): precedence = None if
isinstance(self.current, IdentifierToken): kind = 'normal'
function_name = self.current.name self.Next() # eat function name. elif
isinstance(self.current, UnaryToken): kind = 'unary' self.Next() # eat
'unary'. if not isinstance(self.current, CharacterToken): raise
RuntimeError('Expected an operator after "unary".') function_name =
'unary' + self.current.char self.Next() # eat the operator. elif
isinstance(self.current, BinaryToken): kind = 'binary' self.Next() # eat
'binary'. if not isinstance(self.current, CharacterToken): raise
RuntimeError('Expected an operator after "binary".') function_name =
'binary' + self.current.char self.Next() # eat the operator. if
isinstance(self.current, NumberToken): if not 1 &lt;= self.current.value &lt;=
100: raise RuntimeError('Invalid precedence: must be in range [1,
100].') precedence = self.current.value self.Next() # eat the
precedence. else: raise RuntimeError('Expected function name, "unary" or
"binary" in ' 'prototype.')

::

if self.current != CharacterToken('('):
raise RuntimeError('Expected "(" in prototype.')
self.Next()  # eat '('.

arg_names = []
while isinstance(self.current, IdentifierToken):
arg_names.append(self.current.name)
self.Next()

if self.current != CharacterToken(')'):
raise RuntimeError('Expected ")" in prototype.')

# Success.
self.Next()  # eat ')'.

if kind == 'unary' and len(arg_names) != 1:
raise RuntimeError('Invalid number of arguments for a unary operator.')
elif kind == 'binary' and len(arg_names) != 2:
raise RuntimeError('Invalid number of arguments for a binary operator.')

return PrototypeNode(function_name, arg_names, kind != 'normal', precedence)

# definition ::= 'def' prototype expression def ParseDefinition(self):
self.Next() # eat def. proto = self.ParsePrototype() body =
self.ParseExpression() return FunctionNode(proto, body)

# toplevelexpr ::= expression def ParseTopLevelExpr(self): proto =
PrototypeNode('', []) return FunctionNode(proto, self.ParseExpression())

# external ::= 'extern' prototype def ParseExtern(self): self.Next() #
eat extern. return self.ParsePrototype()

# Top-Level parsing def HandleDefinition(self):
self.Handle(self.ParseDefinition, 'Read a function definition:')

def HandleExtern(self): self.Handle(self.ParseExtern, 'Read an extern:')

def HandleTopLevelExpression(self): try: function =
self.ParseTopLevelExpr().CodeGen() result =
g_llvm_executor.run_function(function, []) print 'Evaluated to:',
result.as_real(Type.double()) except Exception, e: raise#print
'Error:', e try: self.Next() # Skip for error recovery. except: pass

def Handle(self, function, message): try: print message,
function().CodeGen() except Exception, e: raise#print 'Error:', e try:
self.Next() # Skip for error recovery. except: pass

Main driver code.
-----------------

def main(): # Set up the optimizer pipeline. Start with registering info
about how the # target lays out data structures.
g_llvm_pass_manager.add(g_llvm_executor.target_data) # Promote
allocas to registers.
g_llvm_pass_manager.add(PASS_PROMOTE_MEMORY_TO_REGISTER) # Do
simple "peephole" optimizations and bit-twiddling optzns.
g_llvm_pass_manager.add(PASS_INSTRUCTION_COMBINING) # Reassociate
expressions. g_llvm_pass_manager.add(PASS_REASSOCIATE) # Eliminate
Common SubExpressions. g_llvm_pass_manager.add(PASS_GVN) # Simplify
the control flow graph (deleting unreachable blocks, etc).
g_llvm_pass_manager.add(PASS_CFG_SIMPLIFICATION)

g_llvm_pass_manager.initialize()

# Install standard binary operators. # 1 is lowest possible precedence.
40 is the highest. g_binop_precedence['='] = 2
g_binop_precedence['&lt;'] = 10 g_binop_precedence['+'] = 20
g_binop_precedence['-'] = 20 g_binop_precedence['\*'] = 40

# Run the main "interpreter loop". while True: print 'ready&lt;', try: raw
= raw_input() except KeyboardInterrupt: break

::

parser = Parser(Tokenize(raw))
while True:
# top ::= definition | external | expression | EOF
if isinstance(parser.current, EOFToken):
break
if isinstance(parser.current, DefToken):
parser.HandleDefinition()
elif isinstance(parser.current, ExternToken):
parser.HandleExtern()
else:
parser.HandleTopLevelExpression()

# Print out all of the generated code. print '', g_llvm_module

if **name** == '**main**\ ': main()</pre>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. Chapter 7: Extending the Language: Mutable Variables / SSA construction</a><ul>
<li><a class="reference internal" href="#introduction-intro">7.1. Introduction # {#intro}</a></li>
<li><a class="reference internal" href="#why-is-this-a-hard-problem-why">7.2. Why is this a hard problem? # {#why}</a></li>
<li><a class="reference internal" href="#memory-in-llvm-memory">7.3. Memory in LLVM # {#memory}</a></li>
<li><a class="reference internal" href="#mutable-variables-in-kaleidoscope-kalvars">7.4. Mutable Variables in Kaleidoscope # {#kalvars}</a></li>
<li><a class="reference internal" href="#adjusting-existing-variables-for-mutation-adjustments">7.5. Adjusting Existing Variables for Mutation # {#adjustments}</a></li>
<li><a class="reference internal" href="#new-assignment-operator-assignment">7.6. New Assignment Operator # {#assignment}</a></li>
<li><a class="reference internal" href="#user-defined-local-variables-localvars">7.7. User-defined Local Variables # {#localvars}</a></li>
<li><a class="reference internal" href="#full-code-listing-code">7.8. Full Code Listing # {#code}</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="PythonLangImpl6.html"
                        title="previous chapter">6. Chapter 6: Extending the Language: User-defined Operators</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="PythonLangImpl8.html"
                        title="next chapter">&lt;no title&gt;</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/doc/kaleidoscope/PythonLangImpl7.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="PythonLangImpl8.html" title="&lt;no title&gt;"
             >next</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl6.html" title="6. Chapter 6: Extending the Language: User-defined Operators"
             >previous</a> |</li>
        <li><a href="../../index.html">llvmpy 0.8.2 documentation</a> &raquo;</li>
          <li><a href="../examples.html" >Examples and LLVM Tutorials</a> &raquo;</li>
          <li><a href="index.html" >Kaleidoscope</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Mahadevan R (2008-2010), Continuum Analytics (2012).
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>