

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4. Chapter 4: Adding JIT and Optimizer Support &mdash; llvmpy 0.8.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.8.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="llvmpy 0.8.2 documentation" href="../../index.html" />
    <link rel="up" title="Kaleidoscope" href="index.html" />
    <link rel="next" title="5. Chapter 5: Extending the Language: Control Flow" href="PythonLangImpl5.html" />
    <link rel="prev" title="3. Chapter 3: Code generation to LLVM IR" href="PythonLangImpl3.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="PythonLangImpl5.html" title="5. Chapter 5: Extending the Language: Control Flow"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl3.html" title="3. Chapter 3: Code generation to LLVM IR"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">llvmpy 0.8.2 documentation</a> &raquo;</li>
          <li><a href="../examples.html" >Examples and LLVM Tutorials</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Kaleidoscope</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-4-adding-jit-and-optimizer-support">
<h1>4. Chapter 4: Adding JIT and Optimizer Support<a class="headerlink" href="#chapter-4-adding-jit-and-optimizer-support" title="Permalink to this headline">¶</a></h1>
<p>Written by <a class="reference external" href="mailto:sabre&#37;&#52;&#48;nondot&#46;org">Chris Lattner</a> and <a class="reference external" href="http://max99x.com">Max
Shawabkeh</a></p>
<div class="section" id="introduction-intro">
<h2>4.1. Introduction # {#intro}<a class="headerlink" href="#introduction-intro" title="Permalink to this headline">¶</a></h2>
<p>Welcome to Chapter 4 of the <a class="reference external" href="http://www.llvm.org/docs/tutorial/index.html">Implementing a language with
LLVM</a> tutorial. Chapters
1-3 described the implementation of a simple language and added support
for generating LLVM IR. This chapter describes two new techniques:
adding optimizer support to your language, and adding JIT compiler
support. These additions will demonstrate how to get nice, efficient
code for the Kaleidoscope language.</p>
</div>
<hr class="docutils" />
<div class="section" id="trivial-constant-folding-trivialconstfold">
<h2>4.2. Trivial Constant Folding # {#trivialconstfold}<a class="headerlink" href="#trivial-constant-folding-trivialconstfold" title="Permalink to this headline">¶</a></h2>
<p>Our demonstration for Chapter 3 is elegant and easy to extend.
Unfortunately, it does not produce wonderful code. The LLVM Builder,
however, does give us obvious optimizations when compiling simple code:</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def <span class="nb">test</span><span class="o">(</span>x<span class="o">)</span> 1+2+x Read <span class="k">function </span>definition:
define double @test<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span> entry: %addtmp <span class="o">=</span> fadd double
3.000000e+00, %x ret double %addtmp <span class="o">}</span>
</pre></div>
</div>
<p>This code is not a literal transcription of the AST built by parsing the
input. That would be:</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def <span class="nb">test</span><span class="o">(</span>x<span class="o">)</span> 1+2+x Read <span class="k">function </span>definition:
define double @test<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span> entry: %addtmp <span class="o">=</span> fadd double
2.000000e+00, 1.000000e+00 %addtmp1 <span class="o">=</span> fadd double %addtmp, %x ret double
%addtmp1 <span class="o">}</span>
</pre></div>
</div>
<p>Constant folding, as seen above, in particular, is a very common and
very important optimization: so much so that many language implementors
implement constant folding support in their AST representation.</p>
<p>With LLVM, you don&#8217;t need this support in the AST. Since all calls to
build LLVM IR go through the LLVM IR builder, the builder itself checked
to see if there was a constant folding opportunity when you call it. If
so, it just does the constant fold and return the constant instead of
creating an instruction.</p>
<p>Well, that was easy :). In practice, we recommend always using
<tt class="docutils literal"><span class="pre">llvm.core.Builder</span></tt> when generating code like this. It has no
&#8220;syntactic overhead&#8221; for its use (you don&#8217;t have to uglify your compiler
with constant checks everywhere) and it can dramatically reduce the
amount of LLVM IR that is generated in some cases (particular for
languages with a macro preprocessor or that use a lot of constants).</p>
<p>On the other hand, the <tt class="docutils literal"><span class="pre">Builder</span></tt> is limited by the fact that it does
all of its analysis inline with the code as it is built. If you take a
slightly more complex example:</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def <span class="nb">test</span><span class="o">(</span>x<span class="o">)</span> <span class="o">(</span>1+2+x<span class="o">)</span><span class="se">\*</span><span class="o">(</span>x+<span class="o">(</span>1+2<span class="o">))</span> Read a
<span class="k">function </span>definition: define double @test<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span> entry: %addtmp <span class="o">=</span>
fadd double 3.000000e+00, %x ; <span class="o">[</span><span class="c">#uses=1] %addtmp1 = fadd double %x,</span>
3.000000e+00 ; <span class="o">[</span><span class="c">#uses=1] %multmp = fmul double %addtmp, %addtmp1 ;</span>
<span class="o">[</span><span class="c">#uses=1] ret double %multmp }</span>
</pre></div>
</div>
<p>In this case, the LHS and RHS of the multiplication are the same value.
We&#8217;d really like to see this generate&#8221;<tt class="docutils literal"><span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">x+3;</span> <span class="pre">result</span> <span class="pre">=</span> <span class="pre">tmp*tmp;</span></tt>
instead of computing <tt class="docutils literal"><span class="pre">x+3</span></tt> twice.</p>
<p>Unfortunately, no amount of local analysis will be able to detect and
correct this. This requires two transformations: reassociation of
expressions (to make the add&#8217;s lexically identical) and Common
Subexpression Elimination (CSE) to delete the redundant add instruction.
Fortunately, LLVM provides a broad range of optimizations that you can
use, in the form of &#8220;passes&#8221;.</p>
</div>
<hr class="docutils" />
<div class="section" id="llvm-optimization-passes-optimizerpasses">
<h2>4.3. LLVM Optimization Passes # {#optimizerpasses}<a class="headerlink" href="#llvm-optimization-passes-optimizerpasses" title="Permalink to this headline">¶</a></h2>
<p>LLVM provides many optimization passes, which do many different sorts of
things and have different tradeoffs. Unlike other systems, LLVM doesn&#8217;t
hold to the mistaken notion that one set of optimizations is right for
all languages and for all situations. LLVM allows a compiler implementor
to make complete decisions about what optimizations to use, in which
order, and in what situation.</p>
<p>As a concrete example, LLVM supports both &#8220;whole module&#8221; passes, which
look across as large of body of code as they can (often a whole file,
but if run at link time, this can be a substantial portion of the whole
program). It also supports and includes &#8220;per-function&#8221; passes which just
operate on a single function at a time, without looking at other
functions. For more information on passes and how they are run, see the
<a class="reference external" href="http://www.llvm.org/docs/WritingAnLLVMPass.html">How to Write a Pass</a>
document and the <a class="reference external" href="http://www.llvm.org/docs/Passes.html">List of LLVM
Passes</a>.</p>
<p>For Kaleidoscope, we are currently generating functions on the fly, one
at a time, as the user types them in. We aren&#8217;t shooting for the
ultimate optimization experience in this setting, but we also want to
catch the easy and quick stuff where possible. As such, we will choose
to run a few per-function optimizations as the user types the function
in. If we wanted to make a &#8220;static Kaleidoscope compiler&#8221;, we would use
exactly the code we have now, except that we would defer running the
optimizer until the entire file has been parsed.</p>
<p>In order to get per-function optimizations going, we need to set up a
<a class="reference external" href="http://www.llvm.org/docs/WritingAnLLVMPass.html#passmanager">FunctionPassManager</a>
to hold and organize the LLVM optimizations that we want to run. Once we
have that, we can add a set of optimizations to run. The code looks like
this:</p>
<div class="highlight-python"><pre># The function optimization passes manager.
g_llvm_pass_manager = FunctionPassManager.new(g_llvm_module)

# The LLVM execution engine.
g_llvm_executor = ExecutionEngine.new(g_llvm_module)

...

def main(): # Set up the optimizer pipeline. Start with registering info
about how the # target lays out data structures.
g_llvm_pass_manager.add(g_llvm_executor.target_data) # Do simple
"peephole" optimizations and bit-twiddling optzns.
g_llvm_pass_manager.add(PASS_INSTRUCTION_COMBINING) # Reassociate
expressions. g_llvm_pass_manager.add(PASS_REASSOCIATE) # Eliminate
Common SubExpressions. g_llvm_pass_manager.add(PASS_GVN) # Simplify
the control flow graph (deleting unreachable blocks, etc).
g_llvm_pass_manager.add(PASS_CFG_SIMPLIFICATION)

g_llvm_pass_manager.initialize()</pre>
</div>
<p>This code defines a <tt class="docutils literal"><span class="pre">FunctionPassManager</span></tt>, <tt class="docutils literal"><span class="pre">g_llvm_pass_manager</span></tt>.
Once it is set up, we use a series of &#8220;add&#8221; calls to add a bunch of LLVM
passes. The first pass is basically boilerplate, it adds a pass so that
later optimizations know how the data structures in the program are laid
out. (The &#8220;<tt class="docutils literal"><span class="pre">g_llvm_executor</span></tt>&#8221; variable is related to the JIT, which
we will get to in the next section.) In this case, we choose to add 4
optimization passes. The passes we chose here are a pretty standard set
of &#8220;cleanup&#8221; optimizations that are useful for a wide variety of code. I
won&#8217;t delve into what they do but, believe me, they are a good starting
place :).</p>
<p>Once the pass manager is set up, we need to make use of it. We do this
by running it after our newly created function is constructed (in
<tt class="docutils literal"><span class="pre">FunctionNode.CodeGen</span></tt>), but before it is returned to the client:</p>
<div class="highlight-python"><pre>return_value = self.body.CodeGen()
g_llvm_builder.ret(return_value)

::

# Validate the generated code, checking for consistency.
function.verify()

# Optimize the function.
g_llvm_pass_manager.run(function)</pre>
</div>
<p>As you can see, this is pretty straightforward. The
<tt class="docutils literal"><span class="pre">FunctionPassManager</span></tt> optimizes and updates the LLVM Function in
place, improving (hopefully) its body. With this in place, we can try
our test above again:</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def <span class="nb">test</span><span class="o">(</span>x<span class="o">)</span> <span class="o">(</span>1+2+x<span class="o">)</span><span class="se">\*</span><span class="o">(</span>x+<span class="o">(</span>1+2<span class="o">))</span> Read a
<span class="k">function </span>definition: define double @test<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span> entry: %addtmp <span class="o">=</span>
fadd double %x, 3.000000e+00 ; <span class="o">[</span><span class="c">#uses=2] %multmp = fmul double %addtmp,</span>
%addtmp ; <span class="o">[</span><span class="c">#uses=1] ret double %multmp }</span>
</pre></div>
</div>
<p>As expected, we now get our nicely optimized code, saving a floating
point add instruction from every execution of this function.</p>
<p>LLVM provides a wide variety of optimizations that can be used in
certain circumstances. Some <a class="reference external" href="http://www.llvm.org/docs/Passes.html">documentation about the various
passes</a> is available, but it
isn&#8217;t very complete. Another good source of ideas can come from looking
at the passes that <tt class="docutils literal"><span class="pre">llvm-gcc</span></tt> or <tt class="docutils literal"><span class="pre">llvm-ld</span></tt> run to get started. The
<tt class="docutils literal"><span class="pre">opt</span></tt> tool allows you to experiment with passes from the command line,
so you can see if they do anything.</p>
<p>Now that we have reasonable code coming out of our front-end, lets talk
about executing it!</p>
</div>
<hr class="docutils" />
<div class="section" id="adding-a-jit-compiler-jit">
<h2>4.4. Adding a JIT Compiler # {#jit}<a class="headerlink" href="#adding-a-jit-compiler-jit" title="Permalink to this headline">¶</a></h2>
<p>Code that is available in LLVM IR can have a wide variety of tools
applied to it. For example, you can run optimizations on it (as we did
above), you can dump it out in textual or binary forms, you can compile
the code to an assembly file (.s) for some target, or you can JIT
compile it. The nice thing about the LLVM IR representation is that it
is the &#8220;common currency&#8221; between many different parts of the compiler.</p>
<p>In this section, we&#8217;ll add JIT compiler support to our interpreter. The
basic idea that we want for Kaleidoscope is to have the user enter
function bodies as they do now, but immediately evaluate the top-level
expressions they type in. For example, if they type in &#8220;1 + 2&#8221;, we
should evaluate and print out 3. If they define a function, they should
be able to call it from the command line.</p>
<p>In order to do this, we first declare and initialize the JIT. This is
done by adding and initializing a global variable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The LLVM execution engine. g_llvm_executor =</span>
<span class="n">ExecutionEngine</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">g_llvm_module</span><span class="p">)</span>
</pre></div>
</div>
<p>This creates an abstract &#8220;Execution Engine&#8221; which can be either a JIT
compiler or the LLVM interpreter. LLVM will automatically pick a JIT
compiler for you if one is available for your platform, otherwise it
will fall back to the interpreter.</p>
<p>Once the <tt class="docutils literal"><span class="pre">ExecutionEngine</span></tt> is created, the JIT is ready to be used. We
can use the <tt class="docutils literal"><span class="pre">run_function</span></tt> method of the execution engine to execute a
compiled function and get its return value. In our case, this means that
we can change the code that parses a top-level expression to look like
this:</p>
<div class="highlight-python"><pre>def HandleTopLevelExpression(self): try: function
= self.ParseTopLevelExpr().CodeGen() result =
g_llvm_executor.run_function(function, []) print 'Evaluated to:',
result.as_real(Type.double()) except Exception, e: print 'Error:', e
try: self.Next() # Skip for error recovery. except: pass {% endhighlight
%}

Recall that we compile top-level expressions into a self-contained LLVM
function that takes no arguments and returns the computed double.

With just these two changes, lets see how Kaleidoscope works now!

{% highlight python %} ready&gt; 4+5 Read a top level expression: define
double @0() { entry: ret double 9.000000e+00 }

Evaluated to: 9.0</pre>
</div>
<p>Well this looks like it is basically working. The dump of the function
shows the &#8220;no argument function that always returns double&#8221; that we
synthesize for each top-level expression that is typed in. This
demonstrates very basic functionality, but can we do more?</p>
<div class="highlight-python"><pre>ready&gt; def testfunc(x y) x + y\*2 Read a function
definition: define double @testfunc(double %x, double %y) { entry:
%multmp = fmul double %y, 2.000000e+00 ; [#uses=1] %addtmp = fadd double
%multmp, %x ; [#uses=1] ret double %addtmp }

ready&gt; testfunc(4, 10) Read a top level expression: define double @0() {
entry: %calltmp = call double @testfunc(double 4.000000e+00, double
1.000000e+01) ; [#uses=1] ret double %calltmp }

*Evaluated to: 24.0*</pre>
</div>
<p>This illustrates that we can now call user code, but there is something
a bit subtle going on here. Note that we only invoke the JIT on the
anonymous functions that <em>call testfunc</em>, but we never invoked it on
<em>testfunc</em> itself. What actually happened here is that the JIT scanned
for all non-JIT&#8217;d functions transitively called from the anonymous
function and compiled all of them before returning from
<tt class="docutils literal"><span class="pre">run_function()</span></tt>.</p>
<p>The JIT provides a number of other more advanced interfaces for things
like freeing allocated machine code, rejit&#8217;ing functions to update them,
etc. However, even with this simple code, we get some surprisingly
powerful capabilities - check this out (I removed the dump of the
anonymous functions, you should get the idea by now :) :</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; extern sin<span class="o">(</span>x<span class="o">)</span> Read an extern: <span class="nb">declare </span>double
@sin<span class="o">(</span>double<span class="o">)</span>

ready&gt; extern cos<span class="o">(</span>x<span class="o">)</span> Read an extern: <span class="nb">declare </span>double @cos<span class="o">(</span>double<span class="o">)</span>

ready&gt; sin<span class="o">(</span>1.0<span class="o">)</span> *Evaluated to: 0.841470984808*

ready&gt; def foo<span class="o">(</span>x<span class="o">)</span> sin<span class="o">(</span>x<span class="o">)</span><span class="se">\ </span>*sin<span class="o">(</span>x<span class="o">)</span> + cos<span class="o">(</span>x<span class="o">)</span>*<span class="se">\ </span>cos<span class="o">(</span>x<span class="o">)</span> Read a <span class="k">function</span>
definition: define double @foo<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span> entry: %calltmp <span class="o">=</span> call
double @sin<span class="o">(</span>double %x<span class="o">)</span> ; <span class="o">[</span><span class="c">#uses=1] %calltmp1 = call double @sin(double</span>
%x<span class="o">)</span> ; <span class="o">[</span><span class="c">#uses=1] %multmp = fmul double %calltmp, %calltmp1 ; [#uses=1]</span>
%calltmp2 <span class="o">=</span> call double @cos<span class="o">(</span>double %x<span class="o">)</span> ; <span class="o">[</span><span class="c">#uses=1] %calltmp3 = call</span>
double @cos<span class="o">(</span>double %x<span class="o">)</span> ; <span class="o">[</span><span class="c">#uses=1] %multmp4 = fmul double %calltmp2,</span>
%calltmp3 ; <span class="o">[</span><span class="c">#uses=1] %addtmp = fadd double %multmp, %multmp4 ;</span>
<span class="o">[</span><span class="c">#uses=1] ret double %addtmp }</span>

ready&gt; foo<span class="o">(</span>4.0<span class="o">)</span> *Evaluated to: 1.000000*
</pre></div>
</div>
<p>Whoa, how does the JIT know about sin and cos? The answer is
surprisingly simple: in this example, the JIT started execution of a
function and got to a function call. It realized that the function was
not yet JIT compiled and invoked the standard set of routines to resolve
the function. In this case, there is no body defined for the function,
so the JIT ended up calling <tt class="docutils literal"><span class="pre">dlsym(&quot;sin&quot;)</span></tt> on the Python process that
is hosting our Kaleidoscope prompt. Since <tt class="docutils literal"><span class="pre">sin</span></tt> is defined within the
JIT&#8217;s address space, it simply patches up calls in the module to call
the libm version of <tt class="docutils literal"><span class="pre">sin</span></tt> directly.</p>
<p>One interesting application of this is that we can now extend the
language by writing arbitrary C++ code to implement operations. For
example, we can create a C file with the following simple function:</p>
<div class="highlight-c"><pre>#include

double putchard(double x) { putchar((char)x); return 0; } {%
endhighlight %}

We can then compile this into a shared library with GCC:

{% highlight bash %} gcc -shared -fPIC -o putchard.so putchard.c {%
endhighlight %}

Now we can load this library into the Python process using
``llvm.core.load_library_permanently`` and access it from Kaleidoscope
to produce simple output to the console:

{% highlight python %} &gt;&gt;&gt; import llvm.core &gt;&gt;&gt;
llvm.core.load_library_permanently('/home/max/llvmpy-tutorial/putchard.so')
&gt;&gt;&gt; import kaleidoscope &gt;&gt;&gt; kaleidoscope.main() ready&gt; extern
putchard(x) Read an extern: declare double @putchard(double)

ready&gt; putchard(65) + putchard(66) + putchard(67) + putchard(10) *ABC*
Evaluated to: 0.0</pre>
</div>
<p>Similar code could be used to implement file I/O, console input, and
many other capabilities in Kaleidoscope.</p>
<p>This completes the JIT and optimizer chapter of the Kaleidoscope
tutorial. At this point, we can compile a non-Turing-complete
programming language, optimize and JIT compile it in a user-driven way.
Next up we&#8217;ll look into <a class="reference external" href="PythonLangImpl5.html">extending the language with control flow
constructs</a>, tackling some interesting LLVM IR
issues along the way.</p>
</div>
<hr class="docutils" />
<div class="section" id="full-code-listing-code">
<h2>4.5. Full Code Listing # {#code}<a class="headerlink" href="#full-code-listing-code" title="Permalink to this headline">¶</a></h2>
<p>Here is the complete code listing for our running example, enhanced with
the LLVM JIT and optimizer:</p>
<div class="highlight-python"><pre>#!/usr/bin/env python

import re from llvm.core import Module, Constant, Type, Function,
Builder, FCMP_ULT from llvm.ee import ExecutionEngine, TargetData from
llvm.passes import FunctionPassManager from llvm.passes import
(PASS_INSTRUCTION_COMBINING, PASS_REASSOCIATE, PASS_GVN,
PASS_CFG_SIMPLIFICATION)

Globals
-------

# The LLVM module, which holds all the IR code.
g_llvm_module = Module.new('my cool jit')

# The LLVM instruction builder. Created whenever a new function is entered.
g_llvm_builder = None

# A dictionary that keeps track of which values are defined in the current scope
# and what their LLVM representation is.
g_named_values = {}

# The function optimization passes manager.
g_llvm_pass_manager = FunctionPassManager.new(g_llvm_module)

# The LLVM execution engine.
g_llvm_executor = ExecutionEngine.new(g_llvm_module)

Lexer
-----

# The lexer yields one of these types for each token.
class EOFToken(object): pass

class DefToken(object): pass

class ExternToken(object): pass

class IdentifierToken(object): def **init**\ (self, name): self.name =
name

class NumberToken(object): def **init**\ (self, value): self.value =
value

class CharacterToken(object): def **init**\ (self, char): self.char =
char def **eq**\ (self, other): return isinstance(other, CharacterToken)
and self.char == other.char def **ne**\ (self, other): return not self
== other

# Regular expressions that tokens and comments of our language.
REGEX_NUMBER = re.compile('[0-9]+(?:.[0-9]+)?') REGEX_IDENTIFIER =
re.compile('[a-zA-Z][a-zA-Z0-9]\ *') REGEX_COMMENT = re.compile('#.*')

def Tokenize(string): while string: # Skip whitespace. if
string[0].isspace(): string = string[1:] continue

::

# Run regexes.
comment_match = REGEX_COMMENT.match(string)
number_match = REGEX_NUMBER.match(string)
identifier_match = REGEX_IDENTIFIER.match(string)

# Check if any of the regexes matched and yield the appropriate result.
if comment_match:
comment = comment_match.group(0)
string = string[len(comment):]
elif number_match:
number = number_match.group(0)
yield NumberToken(float(number))
string = string[len(number):]
elif identifier_match:
identifier = identifier_match.group(0)
# Check if we matched a keyword.
if identifier == 'def':
yield DefToken()
elif identifier == 'extern':
yield ExternToken()
else:
yield IdentifierToken(identifier)
string = string[len(identifier):]
else:
# Yield the ASCII value of the unknown character.
yield CharacterToken(string[0])
string = string[1:]

yield EOFToken()

Abstract Syntax Tree (aka Parse Tree)
-------------------------------------

# Base class for all expression nodes.
class ExpressionNode(object): pass

# Expression class for numeric literals like "1.0".
class NumberExpressionNode(ExpressionNode):

def **init**\ (self, value): self.value = value

def CodeGen(self): return Constant.real(Type.double(), self.value)

# Expression class for referencing a variable, like "a".
class VariableExpressionNode(ExpressionNode):

def **init**\ (self, name): self.name = name

def CodeGen(self): if self.name in g_named_values: return
g_named_values[self.name] else: raise RuntimeError('Unknown variable
name: ' + self.name)

# Expression class for a binary operator.
class BinaryOperatorExpressionNode(ExpressionNode):

def **init**\ (self, operator, left, right): self.operator = operator
self.left = left self.right = right

def CodeGen(self): left = self.left.CodeGen() right =
self.right.CodeGen()

::

if self.operator == '+':
return g_llvm_builder.fadd(left, right, 'addtmp')
elif self.operator == '-':
return g_llvm_builder.fsub(left, right, 'subtmp')
elif self.operator == '*':
return g_llvm_builder.fmul(left, right, 'multmp')
elif self.operator == '&lt;':
result = g_llvm_builder.fcmp(FCMP_ULT, left, right, 'cmptmp')
# Convert bool 0 or 1 to double 0.0 or 1.0.
return g_llvm_builder.uitofp(result, Type.double(), 'booltmp')
else:
raise RuntimeError('Unknown binary operator.')

# Expression class for function calls.
class CallExpressionNode(ExpressionNode):

def **init**\ (self, callee, args): self.callee = callee self.args =
args

def CodeGen(self): # Look up the name in the global module table. callee
= g_llvm_module.get_function_named(self.callee)

::

# Check for argument mismatch error.
if len(callee.args) != len(self.args):
raise RuntimeError('Incorrect number of arguments passed.')

arg_values = [i.CodeGen() for i in self.args]

return g_llvm_builder.call(callee, arg_values, 'calltmp')

# This class represents the "prototype" for a function, which captures its name,
# and its argument names (thus implicitly the number of arguments the function
# takes).
class PrototypeNode(object):

def **init**\ (self, name, args): self.name = name self.args = args

def CodeGen(self): # Make the function type, eg. double(double,double).
funct_type = Type.function( Type.double(), [Type.double()] \*
len(self.args), False)

::

function = Function.new(g_llvm_module, funct_type, self.name)

# If the name conflicted, there was already something with the same name.
# If it has a body, don't allow redefinition or reextern.
if function.name != self.name:
function.delete()
function = g_llvm_module.get_function_named(self.name)

# If the function already has a body, reject this.
if not function.is_declaration:
raise RuntimeError('Redefinition of function.')

# If F took a different number of args, reject.
if len(callee.args) != len(self.args):
raise RuntimeError('Redeclaration of a function with different number '
'of args.')

# Set names for all arguments and add them to the variables symbol table.
for arg, arg_name in zip(function.args, self.args):
arg.name = arg_name
# Add arguments to variable symbol table.
g_named_values[arg_name] = arg

return function

# This class represents a function definition itself.
class FunctionNode(object):

def **init**\ (self, prototype, body): self.prototype = prototype
self.body = body

def CodeGen(self): # Clear scope. g_named_values.clear()

::

# Create a function object.
function = self.prototype.CodeGen()

# Create a new basic block to start insertion into.
block = function.append_basic_block('entry')
global g_llvm_builder
g_llvm_builder = Builder.new(block)

# Finish off the function.
try:
return_value = self.body.CodeGen()
g_llvm_builder.ret(return_value)

# Validate the generated code, checking for consistency.
function.verify()

# Optimize the function.
g_llvm_pass_manager.run(function)
except:
function.delete()
raise

return function

Parser
------

class Parser(object):

def **init**\ (self, tokens, binop_precedence): self.tokens = tokens
self.binop_precedence = binop_precedence self.Next()

# Provide a simple token buffer. Parser.current is the current token the
# parser is looking at. Parser.Next() reads another token from the lexer
and # updates Parser.current with its results. def Next(self):
self.current = self.tokens.next()

# Gets the precedence of the current token, or -1 if the token is not a
binary # operator. def GetCurrentTokenPrecedence(self): if
isinstance(self.current, CharacterToken): return
self.binop_precedence.get(self.current.char, -1) else: return -1

# identifierexpr ::= identifier \| identifier '(' expression\* ')' def
ParseIdentifierExpr(self): identifier_name = self.current.name
self.Next() # eat identifier.

::

if self.current != CharacterToken('('):  # Simple variable reference.
return VariableExpressionNode(identifier_name)

# Call.
self.Next()  # eat '('.
args = []
if self.current != CharacterToken(')'):
while True:
args.append(self.ParseExpression())
if self.current == CharacterToken(')'):
break
elif self.current != CharacterToken(','):
raise RuntimeError('Expected ")" or "," in argument list.')
self.Next()

self.Next()  # eat ')'.
return CallExpressionNode(identifier_name, args)

# numberexpr ::= number def ParseNumberExpr(self): result =
NumberExpressionNode(self.current.value) self.Next() # consume the
number. return result

# parenexpr ::= '(' expression ')' def ParseParenExpr(self): self.Next()
# eat '('.

::

contents = self.ParseExpression()

if self.current != CharacterToken(')'):
raise RuntimeError('Expected ")".')
self.Next()  # eat ')'.

return contents

# primary ::= identifierexpr \| numberexpr \| parenexpr def
ParsePrimary(self): if isinstance(self.current, IdentifierToken): return
self.ParseIdentifierExpr() elif isinstance(self.current, NumberToken):
return self.ParseNumberExpr() elif self.current == CharacterToken('('):
return self.ParseParenExpr() else: raise RuntimeError('Unknown token
when expecting an expression.')

# binoprhs ::= (operator primary)\* def ParseBinOpRHS(self, left,
left_precedence): # If this is a binary operator, find its precedence.
while True: precedence = self.GetCurrentTokenPrecedence()

::

# If this is a binary operator that binds at least as tightly as the
# current one, consume it; otherwise we are done.
if precedence &lt; left_precedence:
return left

binary_operator = self.current.char
self.Next()  # eat the operator.

# Parse the primary expression after the binary operator.
right = self.ParsePrimary()

# If binary_operator binds less tightly with right than the operator after
# right, let the pending operator take right as its left.
next_precedence = self.GetCurrentTokenPrecedence()
if precedence &lt; next_precedence:
right = self.ParseBinOpRHS(right, precedence + 1)

# Merge left/right.
left = BinaryOperatorExpressionNode(binary_operator, left, right)

# expression ::= primary binoprhs def ParseExpression(self): left =
self.ParsePrimary() return self.ParseBinOpRHS(left, 0)

# prototype ::= id '(' id\* ')' def ParsePrototype(self): if not
isinstance(self.current, IdentifierToken): raise RuntimeError('Expected
function name in prototype.')

::

function_name = self.current.name
self.Next()  # eat function name.

if self.current != CharacterToken('('):
raise RuntimeError('Expected "(" in prototype.')
self.Next()  # eat '('.

arg_names = []
while isinstance(self.current, IdentifierToken):
arg_names.append(self.current.name)
self.Next()

if self.current != CharacterToken(')'):
raise RuntimeError('Expected ")" in prototype.')

# Success.
self.Next()  # eat ')'.

return PrototypeNode(function_name, arg_names)

# definition ::= 'def' prototype expression def ParseDefinition(self):
self.Next() # eat def. proto = self.ParsePrototype() body =
self.ParseExpression() return FunctionNode(proto, body)

# toplevelexpr ::= expression def ParseTopLevelExpr(self): proto =
PrototypeNode('', []) return FunctionNode(proto, self.ParseExpression())

# external ::= 'extern' prototype def ParseExtern(self): self.Next() #
eat extern. return self.ParsePrototype()

# Top-Level parsing def HandleDefinition(self):
self.Handle(self.ParseDefinition, 'Read a function definition:')

def HandleExtern(self): self.Handle(self.ParseExtern, 'Read an extern:')

def HandleTopLevelExpression(self): try: function =
self.ParseTopLevelExpr().CodeGen() result =
g_llvm_executor.run_function(function, []) print 'Evaluated to:',
result.as_real(Type.double()) except Exception, e: print 'Error:', e
try: self.Next() # Skip for error recovery. except: pass

def Handle(self, function, message): try: print message,
function().CodeGen() except Exception, e: print 'Error:', e try:
self.Next() # Skip for error recovery. except: pass

Main driver code.
-----------------

def main(): # Set up the optimizer pipeline. Start with registering info
about how the # target lays out data structures.
g_llvm_pass_manager.add(g_llvm_executor.target_data) # Do simple
"peephole" optimizations and bit-twiddling optzns.
g_llvm_pass_manager.add(PASS_INSTRUCTION_COMBINING) # Reassociate
expressions. g_llvm_pass_manager.add(PASS_REASSOCIATE) # Eliminate
Common SubExpressions. g_llvm_pass_manager.add(PASS_GVN) # Simplify
the control flow graph (deleting unreachable blocks, etc).
g_llvm_pass_manager.add(PASS_CFG_SIMPLIFICATION)

g_llvm_pass_manager.initialize()

# Install standard binary operators. # 1 is lowest possible precedence.
40 is the highest. operator_precedence = { '&lt;': 10, '+': 20, '-': 20,
'\*': 40 }

# Run the main "interpreter loop". while True: print 'ready&gt;', try: raw
= raw_input() except KeyboardInterrupt: break

::

parser = Parser(Tokenize(raw), operator_precedence)
while True:
# top ::= definition | external | expression | EOF
if isinstance(parser.current, EOFToken):
break
if isinstance(parser.current, DefToken):
parser.HandleDefinition()
elif isinstance(parser.current, ExternToken):
parser.HandleExtern()
else:
parser.HandleTopLevelExpression()

# Print out all of the generated code. print '', g_llvm_module

if **name** == '**main**\ ': main()</pre>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. Chapter 4: Adding JIT and Optimizer Support</a><ul>
<li><a class="reference internal" href="#introduction-intro">4.1. Introduction # {#intro}</a></li>
<li><a class="reference internal" href="#trivial-constant-folding-trivialconstfold">4.2. Trivial Constant Folding # {#trivialconstfold}</a></li>
<li><a class="reference internal" href="#llvm-optimization-passes-optimizerpasses">4.3. LLVM Optimization Passes # {#optimizerpasses}</a></li>
<li><a class="reference internal" href="#adding-a-jit-compiler-jit">4.4. Adding a JIT Compiler # {#jit}</a></li>
<li><a class="reference internal" href="#full-code-listing-code">4.5. Full Code Listing # {#code}</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="PythonLangImpl3.html"
                        title="previous chapter">3. Chapter 3: Code generation to LLVM IR</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="PythonLangImpl5.html"
                        title="next chapter">5. Chapter 5: Extending the Language: Control Flow</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/doc/kaleidoscope/PythonLangImpl4.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="PythonLangImpl5.html" title="5. Chapter 5: Extending the Language: Control Flow"
             >next</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl3.html" title="3. Chapter 3: Code generation to LLVM IR"
             >previous</a> |</li>
        <li><a href="../../index.html">llvmpy 0.8.2 documentation</a> &raquo;</li>
          <li><a href="../examples.html" >Examples and LLVM Tutorials</a> &raquo;</li>
          <li><a href="index.html" >Kaleidoscope</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Mahadevan R (2008-2010), Continuum Analytics (2012).
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>