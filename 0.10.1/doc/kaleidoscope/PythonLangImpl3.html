

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3. Chapter 3: Code generation to LLVM IR &mdash; llvmpy 0.9.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="llvmpy 0.9.0 documentation" href="../../index.html" />
    <link rel="up" title="Kaleidoscope" href="index.html" />
    <link rel="next" title="4. Chapter 4: Adding JIT and Optimizer Support" href="PythonLangImpl4.html" />
    <link rel="prev" title="2. Chapter 2: Implementing a Parser and AST" href="PythonLangImpl2.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl4.html" title="4. Chapter 4: Adding JIT and Optimizer Support"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl2.html" title="2. Chapter 2: Implementing a Parser and AST"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">llvmpy 0.9.0 documentation</a> &raquo;</li>
          <li><a href="../examples.html" >Examples and LLVM Tutorials</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Kaleidoscope</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-3-code-generation-to-llvm-ir">
<h1>3. Chapter 3: Code generation to LLVM IR<a class="headerlink" href="#chapter-3-code-generation-to-llvm-ir" title="Permalink to this headline">¶</a></h1>
<p>Written by <a class="reference external" href="mailto:sabre&#37;&#52;&#48;nondot&#46;org">Chris Lattner</a> and <a class="reference external" href="http://max99x.com">Max
Shawabkeh</a></p>
<div class="section" id="introduction">
<h2>3.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Welcome to Chapter 3 of the <a class="reference external" href="http://www.llvm.org/docs/tutorial/index.html">Implementing a language with
LLVM</a> tutorial. This
chapter shows you how to transform the <a class="reference external" href="PythonLangImpl2.html">Abstract Syntax
Tree</a>, built in Chapter 2, into LLVM IR. This
will teach you a little bit about how LLVM does things, as well as
demonstrate how easy it is to use. It&#8217;s much more work to build a lexer
and parser than it is to generate LLVM IR code. :)</p>
<p><strong>Please note</strong>: the code in this chapter and later requires llvmpy 0.6
and LLVM 2.7. Earlier versions will most likely not work with it. Also
note that you need to use a version of this tutorial that matches your
llvmpy release: If you are using an official llvmpy release, use the
version of the documentation on the <a class="reference external" href="http://www.mdevan.org/llvmpy/examples.html">llvmpy examples
page</a></p>
</div>
<hr class="docutils" />
<div class="section" id="code-generation-setup">
<h2>3.2. Code Generation Setup<a class="headerlink" href="#code-generation-setup" title="Permalink to this headline">¶</a></h2>
<p>In order to generate LLVM IR, we want some simple setup to get started.
First we define code generation methods in each AST node class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Expression class for numeric literals like &quot;1.0&quot;.</span>
<span class="k">class</span> <span class="nc">NumberExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="o">...</span>

<span class="c"># Expression class for referencing a variable, like &quot;a&quot;.</span>
<span class="k">class</span> <span class="nc">VariableExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="o">...</span>

<span class="o">...</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">CodeGen</span></tt> method says to emit IR for that AST node along with all
the things it depends on, and they all return an LLVM Value object.
&#8220;Value&#8221; is the class used to represent a &#8220;<a class="reference external" href="http://en.wikipedia.org/wiki/Static_single_assignment_form">Static Single Assignment
(SSA)</a>
register&#8221; or &#8220;SSA value&#8221; in LLVM. The most distinct aspect of SSA values
is that their value is computed as the related instruction executes, and
it does not get a new value until (and if) the instruction re-executes.
In other words, there is no way to &#8220;change&#8221; an SSA value. For more
information, please read up on <a class="reference external" href="http://en.wikipedia.org/wiki/Static_single_assignment_form">Static Single
Assignment</a>
- the concepts are really quite natural once you grok them.</p>
<p>We will also need to define some global variables which we will be used
during code generation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The LLVM module, which holds all the IR code.</span>
<span class="n">g_llvm_module</span> <span class="o">=</span> <span class="n">Module</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s">&#39;my cool jit&#39;</span><span class="p">)</span>

<span class="c"># The LLVM instruction builder. Created whenever a new function is entered.</span>
<span class="n">g_llvm_builder</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c"># A dictionary that keeps track of which values are defined in the current scope</span>
<span class="c"># and what their LLVM representation is.</span>
<span class="n">g_named_values</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">g_llvm_module</span></tt> is the LLVM construct that contains all of the
functions and global variables in a chunk of code. In many ways, it is
the top-level structure that the LLVM IR uses to contain code.</p>
<p><tt class="docutils literal"><span class="pre">g_llvm_builder</span></tt> is a helper object that makes it easy to generate
LLVM instructions. Instances of the
<a class="reference external" href="llvm.core.Builder.html">llvm.core.Builder</a> class keep track of the
current place to insert instructions and have methods to create new
instructions. Note that we do not initialize this variable; instead, it
will be initialized whenever we start generating code for a function.</p>
<p>Finally, <tt class="docutils literal"><span class="pre">g_named_values</span></tt> is a dictionary that keeps track of which
values are defined in the current scope and what their LLVM
representation is. In other words, it is a symbol table for the code. In
this form of Kaleidoscope, the only things that can be referenced are
function parameters. As such, function parameters will be in this map
when generating code for their function body.</p>
<p>With these basics in place, we can start talking about how to generate
code for each expression. Note that this assumes that <tt class="docutils literal"><span class="pre">g_llvm_builder</span></tt>
has been set up to generate code <em>into</em> something. For now, we&#8217;ll assume
that this has already been done, and we&#8217;ll just use it to emit code.</p>
</div>
<hr class="docutils" />
<div class="section" id="expression-code-generation">
<h2>3.3. Expression Code Generation<a class="headerlink" href="#expression-code-generation" title="Permalink to this headline">¶</a></h2>
<p>Generating LLVM code for expression nodes is very straightforward: less
than 35 lines of commented code for all four of our expression nodes.
First we&#8217;ll do numeric literals:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">Constant</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>In llvmpy, floating point numeric constants are represented with the
<tt class="docutils literal"><span class="pre">llvm.core.ConstantFP</span></tt> class. To create one, we can use the static
<tt class="docutils literal"><span class="pre">real()</span></tt> method in the <tt class="docutils literal"><span class="pre">llvm.core.Constant</span></tt> class. This code
basically just creates and returns a <tt class="docutils literal"><span class="pre">ConstantFP</span></tt>. Note that in the
LLVM IR constants are all uniqued together and shared. For this reason,
we create the constant through a factory method instead of instantiating
one directly.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">g_named_values</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">g_named_values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Unknown variable name: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>References to variables are also quite simple using LLVM. In the simple
version of Kaleidoscope, we assume that the variable has already been
emitted somewhere and its value is available. In practice, the only
values that can be in the <tt class="docutils literal"><span class="pre">g_named_values</span></tt> dictionary are function
arguments. This code simply checks to see that the specified name is in
the map (if not, an unknown variable is being referenced) and returns
the value for it. In future chapters, we&#8217;ll add support for <a class="reference external" href="PythonLangImpl5.html#for">loop
induction variables</a> in the symbol table,
and for <a class="reference external" href="PythonLangImpl7.html#localvars">local variables</a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
   <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>

   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;+&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fadd</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;addtmp&#39;</span><span class="p">)</span>
   <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fsub</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;subtmp&#39;</span><span class="p">)</span>
   <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fmul</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;multmp&#39;</span><span class="p">)</span>
   <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fcmp</span><span class="p">(</span><span class="n">FCMP_ULT</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;cmptmp&#39;</span><span class="p">)</span>
      <span class="c"># Convert bool 0 or 1 to double 0.0 or 1.0.</span>
      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">uitofp</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="s">&#39;booltmp&#39;</span><span class="p">)</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Unknown binary operator.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Binary operators start to get more interesting. The basic idea here is
that we recursively emit code for the left-hand side of the expression,
then the right-hand side, then we compute the result of the binary
expression depending on which operator is being used.</p>
<p>In the example above, the LLVM builder class is starting to show its
value. <tt class="docutils literal"><span class="pre">g_llvm_builder</span></tt> knows where to insert the newly created
instruction, all you have to do is specify what instruction to create
(e.g. with <tt class="docutils literal"><span class="pre">add</span></tt>), which operands to use (<tt class="docutils literal"><span class="pre">left</span></tt> and <tt class="docutils literal"><span class="pre">right</span></tt> here)
and optionally provide a name for the generated instruction.</p>
<p>One nice thing about LLVM is that the name is just a hint. For instance,
if the code above emits multiple &#8220;addtmp&#8221; variables, LLVM will
automatically provide each one with an increasing, unique numeric
suffix. Local value names for instructions are purely optional, but it
makes it much easier to read the IR dumps.</p>
<p><a class="reference external" href="http://www.llvm.org/docs/LangRef.html#instref">LLVM instructions</a> are
constrained by strict rules: for example, the Left and Right operators
of an <a class="reference external" href="http://www.llvm.org/docs/LangRef.html#i_add">add instruction</a>
must have the same type, and the result type of the add must match the
operand types. Because all values in Kaleidoscope are doubles, this
makes for very simple code for add, sub and mul.</p>
<p>On the other hand, LLVM specifies that the <a class="reference external" href="http://www.llvm.org/docs/LangRef.html#i_fcmp">fcmp
instruction</a> always
returns an &#8216;i1&#8217; value (a one bit integer). The problem with this is that
Kaleidoscope wants the value to be a 0.0 or 1.0 value. In order to get
these semantics, we combine the fcmp instruction with a <a class="reference external" href="http://www.llvm.org/docs/LangRef.html#i_uitofp">uitofp
instruction</a>. This
instruction converts its input integer into a floating point value by
treating the input as an unsigned value. In contrast, if we used the
<a class="reference external" href="http://www.llvm.org/docs/LangRef.html#i_sitofp">sitofp instruction</a>,
the Kaleidoscope <tt class="docutils literal"><span class="pre">&lt;</span></tt> operator would return 0.0 and -1.0, depending on
the input value.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="c"># Look up the name in the global module table.</span>
   <span class="n">callee</span> <span class="o">=</span> <span class="n">g_llvm_module</span><span class="o">.</span><span class="n">get_function_named</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>

   <span class="c"># Check for argument mismatch error.</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">callee</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Incorrect number of arguments passed.&#39;</span><span class="p">)</span>

   <span class="n">arg_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>

   <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">callee</span><span class="p">,</span> <span class="n">arg_values</span><span class="p">,</span> <span class="s">&#39;calltmp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Code generation for function calls is quite straightforward with LLVM.
The code above initially does a function name lookup in the LLVM
Module&#8217;s symbol table. Recall that the LLVM Module is the container that
holds all of the functions we are JIT&#8217;ing. By giving each function the
same name as what the user specifies, we can use the LLVM symbol table
to resolve function names for us.</p>
<p>Once we have the function to call, we codegen each argument that is to
be passed in, and create an LLVM <a class="reference external" href="http://www.llvm.org/docs/LangRef.html#i_call">call
instruction</a>. Note that
LLVM uses the native C calling conventions by default, allowing these
calls to also call into standard library functions like &#8220;sin&#8221; and &#8220;cos&#8221;,
with no additional effort.</p>
<p>This wraps up our handling of the four basic expressions that we have so
far in Kaleidoscope. Feel free to go in and add some more. For example,
by browsing the <a class="reference external" href="http://www.llvm.org/docs/LangRef.html">LLVM language
reference</a> you&#8217;ll find several
other interesting instructions that are really easy to plug into our
basic framework.</p>
</div>
<hr class="docutils" />
<div class="section" id="function-code-generation">
<h2>3.4. Function Code Generation<a class="headerlink" href="#function-code-generation" title="Permalink to this headline">¶</a></h2>
<p>Code generation for prototypes and functions must handle a number of
details, which make their code less beautiful than expression code
generation, but allows us to illustrate some important points. First,
let&#8217;s talk about code generation for prototypes: they are used both for
function bodies and external function declarations. The code starts
with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="c"># Make the function type, eg. double(double,double).</span>
   <span class="n">funct_type</span> <span class="o">=</span> <span class="n">Type</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
      <span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="p">[</span><span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">),</span> <span class="bp">False</span><span class="p">)</span>

   <span class="n">function</span> <span class="o">=</span> <span class="n">Function</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">g_llvm_module</span><span class="p">,</span> <span class="n">funct_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>The call to <tt class="docutils literal"><span class="pre">Type.function</span></tt> creates the <tt class="docutils literal"><span class="pre">FunctionType</span></tt> that should
be used for a given Prototype. Since all function arguments in
Kaleidoscope are of type double, the first line creates a list of &#8220;N&#8221;
LLVM double types. It then uses the <tt class="docutils literal"><span class="pre">Type.function</span></tt> method to create a
function type that takes &#8220;N&#8221; doubles as arguments, returns one double as
a result, and that is not vararg (the False parameter indicates this).
Note that Types in LLVM are uniqued just like Constants are, so you
don&#8217;t instantiate them directly.</p>
<p>The final line above actually creates the function that the prototype
will correspond to. This indicates the type and name to use, as well as
which module to insert into. Note that by default, the function will
have <a class="reference external" href="http://www.llvm.org/docs/LangRef.html#linkage">external
linkage</a>, which means
that the function may be defined outside the current module and/or that
it is callable by functions outside the module. The name passed in is
the name the user specified: since <tt class="docutils literal"><span class="pre">g_llvm_module</span></tt> is specified, this
name is registered in <tt class="docutils literal"><span class="pre">g_llvm_module</span></tt>&#8216;s symbol table, which is used by
the function call code above.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># If the name conflicted, there was already something with the same name.</span>
<span class="c"># If it has a body, don&#39;t allow redefinition or reextern.</span>
<span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
   <span class="n">function</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
   <span class="n">function</span> <span class="o">=</span> <span class="n">g_llvm_module</span><span class="o">.</span><span class="n">get_function_named</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>The Module symbol table works just like the Function symbol table when
it comes to name conflicts: if a new function is created with a name was
previously added to the symbol table, it will get implicitly renamed
when added to the Module. The code above exploits this fact to determine
if there was a previous definition of this function.</p>
<p>In Kaleidoscope, we choose to allow redefinitions of functions in two
cases: first, we want to allow &#8216;extern&#8217;ing a function more than once, as
long as the prototypes for the externs match (since all arguments have
the same type, we just have to check that the number of arguments
match). Second, we want to allow &#8216;extern&#8217;ing a function and then
defining a body for it. This is useful when defining mutually recursive
functions.</p>
<p>In order to implement this, the code above first checks to see if there
is a collision on the name of the function. If so, it deletes the
function we just created (by calling <tt class="docutils literal"><span class="pre">delete</span></tt>) and then calling
<tt class="docutils literal"><span class="pre">get_function_named</span></tt> to get the existing function with the specified
name.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># If the function already has a body, reject this.</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">function</span><span class="o">.</span><span class="n">is_declaration</span><span class="p">:</span>
   <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Redefinition of function.&#39;</span><span class="p">)</span>

<span class="c"># If F took a different number of args, reject.</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">callee</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
   <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Redeclaration of a function with different number &#39;</span>
                      <span class="s">&#39;of args.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to verify the logic above, we first check to see if the
pre-existing function is a forward declaration. Since we don&#8217;t allow
anything after a full definition of the function, the code rejects this
case. If the previous reference to a function was an &#8216;extern&#8217;, we simply
verify that the number of arguments for that definition and this one
match up. If not, we emit an error.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set names for all arguments and add them to the variables symbol table.</span>
<span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">arg_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
   <span class="n">arg</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">arg_name</span>
   <span class="c"># Add arguments to variable symbol</span>
   <span class="n">table</span><span class="o">.</span> <span class="n">g_named_values</span><span class="p">[</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>

<span class="k">return</span> <span class="n">function</span>
</pre></div>
</div>
<p>The last bit of code for prototypes loops over all of the arguments in
the function, setting the name of the LLVM Argument objects to match,
and registering the arguments in the <tt class="docutils literal"><span class="pre">g_named_values</span></tt> map for future
use by the <tt class="docutils literal"><span class="pre">VariableExpressionNode</span></tt>. Note that we don&#8217;t check for
conflicting argument names here (e.g. &#8220;extern foo(a b a)&#8221;). Doing so
would be very straight-forward with the mechanics we have already used
above. Once this is all set up, it returns the Function object to the
caller.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="c"># Clear scope.</span>
   <span class="n">g_named_values</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

   <span class="c"># Create a function object.</span>
   <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
</pre></div>
</div>
<p>Code generation for function definitions starts out simply enough: we
just clear out the <tt class="docutils literal"><span class="pre">g_named_values</span></tt> dictionary to make sure that there
isn&#8217;t anything in it from the last function we compiled and codegen the
prototype. Code generation of the prototype ensures that there is an
LLVM Function object that is ready to go for us.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create a new basic block to start insertion into.</span>
<span class="n">block</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">append_basic_block</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">)</span>
<span class="k">global</span> <span class="n">g_llvm_builder</span>
<span class="n">g_llvm_builder</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we get to the point where <tt class="docutils literal"><span class="pre">g_llvm_builder</span></tt> is set up. The first
line creates a new <a class="reference external" href="http://en.wikipedia.org/wiki/Basic_block">basic
block</a> (named &#8220;entry&#8221;),
which is inserted into the function. The second line declares that the
global <tt class="docutils literal"><span class="pre">g_llvm_builder</span></tt> object is to be changed. The last line creates
a new builder that is set up to insert new instructions into the basic
block we just created. Basic blocks in LLVM are an important part of
functions that define the <a class="reference external" href="http://en.wikipedia.org/wiki/Control_flow_graph">Control Flow
Graph</a>. Since we
don&#8217;t have any control flow, our functions will only contain one block
at this point. We&#8217;ll fix this in <a class="reference external" href="PythonLangImpl5.html">Chapter 5</a> :).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Finish off the function.</span>
<span class="k">try</span><span class="p">:</span>
   <span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
   <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">ret</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span>

   <span class="c"># Validate the generated code, checking for consistency.</span>
   <span class="n">function</span><span class="o">.</span><span class="n">verify</span><span class="p">()</span>
</pre></div>
</div>
<p>Once the insertion point is set up, we call the <tt class="docutils literal"><span class="pre">CodeGen</span></tt> method for
the root expression of the function. If no error happens, this emits
code to compute the expression into the entry block and returns the
value that was computed. Assuming no error, we then create an LLVM <a class="reference external" href="http://www.llvm.org/docs/LangRef.html#i_ret">ret
instruction</a>, which
completes the function. Once the function is built, we call <tt class="docutils literal"><span class="pre">verify</span></tt>,
which is provided by LLVM. This function does a variety of consistency
checks on the generated code, to determine if our compiler is doing
everything right. Using this is important: it can catch a lot of bugs.
Once the function is finished and validated, we return it.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">except</span><span class="p">:</span>
   <span class="n">function</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
   <span class="k">raise</span>

<span class="k">return</span> <span class="n">function</span>
</pre></div>
</div>
<p>The only piece left here is handling of the error case. For simplicity,
we handle this by merely deleting the function we produced with the
<tt class="docutils literal"><span class="pre">delete</span></tt> method. This allows the user to redefine a function that they
incorrectly typed in before: if we didn&#8217;t delete it, it would live in
the symbol table, with a body, preventing future redefinition.</p>
<p>This code does have a bug, though. Since the <tt class="docutils literal"><span class="pre">PrototypeNode::CodeGen</span></tt>
can return a previously defined forward declaration, our code can
actually delete a forward declaration. There are a number of ways to fix
this bug; see what you can come up with! Here is a testcase:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">extern</span> <span class="n">foo</span><span class="p">(</span><span class="n">a</span> <span class="n">b</span><span class="p">)</span>      <span class="c"># ok, defines foo.</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="n">c</span>       <span class="c"># error, &#39;c&#39; is invalid.</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c"># error, unknown function &quot;foo&quot;</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="driver-changes-and-closing-thoughts">
<h2>3.5. Driver Changes and Closing Thoughts<a class="headerlink" href="#driver-changes-and-closing-thoughts" title="Permalink to this headline">¶</a></h2>
<p>For now, code generation to LLVM doesn&#8217;t really get us much, except that
we can look at the pretty IR calls. The sample code inserts calls to
CodeGen into the <tt class="docutils literal"><span class="pre">Handle*</span></tt> functions, and then dumps out the LLVM IR.
This gives a nice way to look at the LLVM IR for simple functions. For
example:</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; 4+5
Read a top-level expression:
define double @0<span class="o">()</span> <span class="o">{</span>
entry:
   ret double 9.000000e+00
<span class="o">}</span>
</pre></div>
</div>
<p>Note how the parser turns the top-level expression into anonymous
functions for us. This will be handy when we add JIT support in the next
chapter. Also note that the code is very literally transcribed, no
optimizations are being performed except simple constant folding done by
the Builder. We will add optimizations explicitly in the next chapter.</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def foo<span class="o">(</span>a b<span class="o">)</span> a *a + 2* a *b + b* b
Read a <span class="k">function </span>definition:
define double @foo<span class="o">(</span>double %a, double %b<span class="o">)</span> <span class="o">{</span>
entry:
   %multmp <span class="o">=</span> fmul double %a, %a              ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %multmp1 <span class="o">=</span> fmul double 2.000000e+00, %a   ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %multmp2 <span class="o">=</span> fmul double %multmp1, %b       ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %addtmp <span class="o">=</span> fadd double %multmp, %multmp2   ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %multmp3 <span class="o">=</span> fmul double %b, %b             ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %addtmp4 <span class="o">=</span> fadd double %addtmp, %multmp3  ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %addtmp4
<span class="o">}</span>
</pre></div>
</div>
<p>This shows some simple arithmetic. Notice the striking similarity to the
LLVM builder calls that we use to create the instructions.</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def bar<span class="o">(</span>a<span class="o">)</span> foo<span class="o">(</span>a, 4.0<span class="o">)</span> + bar<span class="o">(</span>31337<span class="o">)</span>
Read a <span class="k">function </span>definition:
define double @bar<span class="o">(</span>double %a<span class="o">)</span> <span class="o">{</span>
entry:
   %calltmp <span class="o">=</span> call double @foo<span class="o">(</span>double %a, double 4.000000e+00<span class="o">)</span> ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %calltmp1 <span class="o">=</span> call double @bar<span class="o">(</span>double 3.133700e+04<span class="o">)</span>           ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %addtmp <span class="o">=</span> fadd double %calltmp, %calltmp1                   ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %addtmp
<span class="o">}</span>
</pre></div>
</div>
<p>This shows some function calls. Note that this function will take a long
time to execute if you call it. In the future we&#8217;ll add conditional
control flow to actually make recursion useful :).</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; extern cos<span class="o">(</span>x<span class="o">)</span>
Read extern:
<span class="nb">declare </span>double @cos<span class="o">(</span>double<span class="o">)</span>

ready&gt; cos<span class="o">(</span>1.234<span class="o">)</span>
Read a top-level expression:
define double @1<span class="o">()</span> <span class="o">{</span>
entry:
   %calltmp <span class="o">=</span> call double @cos<span class="o">(</span>double 1.234000e+00<span class="o">)</span> ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %calltmp
<span class="o">}</span>
</pre></div>
</div>
<p>This shows an extern for the libm &#8220;cos&#8221; function, and a call to it.</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; ^C
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;my cool jit&#39;</span>

define double @0<span class="o">()</span> <span class="o">{</span>
entry:
   ret double 9.000000e+00
<span class="o">}</span>

define double @foo<span class="o">(</span>double %a, double %b<span class="o">)</span> <span class="o">{</span>
entry:
   %multmp <span class="o">=</span> fmul double %a, %a             ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %multmp1 <span class="o">=</span> fmul double 2.000000e+00, %a  ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %multmp2 <span class="o">=</span> fmul double %multmp1, %b      ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %addtmp <span class="o">=</span> fadd double %multmp, %multmp2  ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %multmp3 <span class="o">=</span> fmul double %b, %b            ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %addtmp4 <span class="o">=</span> fadd double %addtmp, %multmp3 ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %addtmp4
<span class="o">}</span>

define double @bar<span class="o">(</span>double %a<span class="o">)</span> <span class="o">{</span>
entry:
   %calltmp <span class="o">=</span> call double @foo<span class="o">(</span>double %a, double 4.000000e+00<span class="o">)</span> ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %calltmp1 <span class="o">=</span> call double @bar<span class="o">(</span>double 3.133700e+04<span class="o">)</span> ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %addtmp <span class="o">=</span> fadd double %calltmp, %calltmp1 ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %addtmp
<span class="o">}</span>

<span class="nb">declare </span>double @cos<span class="o">(</span>double<span class="o">)</span>

define double @1<span class="o">()</span> <span class="o">{</span>
entry:
   %calltmp <span class="o">=</span> call double @cos<span class="o">(</span>double 1.234000e+00<span class="o">)</span> ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %calltmp
<span class="o">}</span>
</pre></div>
</div>
<p>When you quit the current demo, it dumps out the IR for the entire
module generated. Here you can see the big picture with all the
functions referencing each other.</p>
<p>This wraps up the third chapter of the Kaleidoscope tutorial. Up next,
we&#8217;ll describe how to <a class="reference external" href="PythonLangImpl4.html">add JIT codegen and optimizer
support</a> to this so we can actually start
running code!</p>
</div>
<hr class="docutils" />
<div class="section" id="full-code-listing">
<h2>3.6. Full Code Listing<a class="headerlink" href="#full-code-listing" title="Permalink to this headline">¶</a></h2>
<p>Here is the complete code listing for our running example, enhanced with
the LLVM code generator. Because this uses the llvmpy libraries, you
need to <a class="reference external" href="../download.html">download</a> and
<a class="reference external" href="../userguide.html#install">install</a> them.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">llvm.core</span> <span class="kn">import</span> <span class="n">Module</span><span class="p">,</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Builder</span><span class="p">,</span> <span class="n">FCMP_ULT</span>
</pre></div>
</div>
<div class="section" id="globals">
<h3>3.6.1. Globals<a class="headerlink" href="#globals" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The LLVM module, which holds all the IR code.</span>
<span class="n">g_llvm_module</span> <span class="o">=</span> <span class="n">Module</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s">&#39;my cool jit&#39;</span><span class="p">)</span>

<span class="c"># The LLVM instruction builder. Created whenever a new function is entered.</span>
<span class="n">g_llvm_builder</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c"># A dictionary that keeps track of which values are defined in the current scope</span>
<span class="c"># and what their LLVM representation is.</span>
<span class="n">g_named_values</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="lexer">
<h3>3.6.2. Lexer<a class="headerlink" href="#lexer" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The lexer yields one of these types for each token.</span>
<span class="k">class</span> <span class="nc">EOFToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">pass</span>

<span class="k">class</span> <span class="nc">DefToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ExternToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">pass</span>

<span class="k">class</span> <span class="nc">IdentifierToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="k">class</span> <span class="nc">NumberToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">CharacterToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">char</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">char</span> <span class="o">=</span> <span class="n">char</span>
   <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
         <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CharacterToken</span><span class="p">)</span><span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">char</span>
   <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
      <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

   <span class="c"># Regular expressions that tokens and comments of our language.</span>
   <span class="n">REGEX_NUMBER</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;[0-9]+(?:\.[0-9]+)?&#39;</span><span class="p">)</span>
   <span class="n">REGEX_IDENTIFIER</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;[a-zA-Z][a-zA-Z0-9]*&#39;</span><span class="p">)</span>
   <span class="n">REGEX_COMMENT</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;#.*&#39;</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">Tokenize</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
      <span class="k">while</span> <span class="n">string</span><span class="p">:</span>
         <span class="c"># Skip whitespace.</span>
         <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">continue</span>

         <span class="c"># Run regexes.</span>
         <span class="n">comment_match</span> <span class="o">=</span> <span class="n">REGEX_COMMENT</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
         <span class="n">number_match</span> <span class="o">=</span> <span class="n">REGEX_NUMBER</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
         <span class="n">identifier_match</span> <span class="o">=</span> <span class="n">REGEX_IDENTIFIER</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

         <span class="c"># Check if any of the regexes matched and yield the appropriate result.</span>
         <span class="k">if</span> <span class="n">comment_match</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="n">comment_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">comment</span><span class="p">):]</span>
         <span class="k">elif</span> <span class="n">number_match</span><span class="p">:</span>
            <span class="n">number</span> <span class="o">=</span> <span class="n">number_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">NumberToken</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">):]</span>
         <span class="k">elif</span> <span class="n">identifier_match</span><span class="p">:</span>
            <span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c"># Check if we matched a keyword.</span>
            <span class="k">if</span> <span class="n">identifier</span> <span class="o">==</span> <span class="s">&#39;def&#39;</span><span class="p">:</span>
               <span class="k">yield</span> <span class="n">DefToken</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">identifier</span> <span class="o">==</span> <span class="s">&#39;extern&#39;</span><span class="p">:</span>
               <span class="k">yield</span> <span class="n">ExternToken</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="k">yield</span> <span class="n">IdentifierToken</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span>
               <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">identifier</span><span class="p">):]</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="c"># Yield the ASCII value of the unknown character.</span>
            <span class="k">yield</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

      <span class="k">yield</span> <span class="n">EOFToken</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="abstract-syntax-tree-aka-parse-tree">
<h3>3.6.3. Abstract Syntax Tree (aka Parse Tree)<a class="headerlink" href="#abstract-syntax-tree-aka-parse-tree" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Base class for all expression nodes.</span>
<span class="k">class</span> <span class="nc">ExpressionNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">pass</span>

<span class="c"># Expression class for numeric literals like &quot;1.0&quot;.</span>
<span class="k">class</span> <span class="nc">NumberExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">Constant</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<span class="c"># Expression class for referencing a variable, like &quot;a&quot;.</span>
<span class="k">class</span> <span class="nc">VariableExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">g_named_values</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">g_named_values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Unknown variable name: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="c"># Expression class for a binary operator.</span>
<span class="k">class</span> <span class="nc">BinaryOperatorExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
      <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;+&#39;</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fadd</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;addtmp&#39;</span><span class="p">)</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fsub</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;subtmp&#39;</span><span class="p">)</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fmul</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;multmp&#39;</span><span class="p">)</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
         <span class="n">result</span> <span class="o">=</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fcmp</span><span class="p">(</span><span class="n">FCMP_ULT</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;cmptmp&#39;</span><span class="p">)</span>
         <span class="c"># Convert bool 0 or 1 to double 0.0 or 1.0.</span>
         <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">uitofp</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="s">&#39;booltmp&#39;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Unknown binary operator.&#39;</span><span class="p">)</span>

<span class="c"># Expression class for function calls.</span>
<span class="k">class</span> <span class="nc">CallExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callee</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">callee</span> <span class="o">=</span> <span class="n">callee</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="c"># Look up the name in the global module table.</span>
      <span class="n">callee</span> <span class="o">=</span> <span class="n">g_llvm_module</span><span class="o">.</span><span class="n">get_function_named</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>

      <span class="c"># Check for argument mismatch error.</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">callee</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Incorrect number of arguments passed.&#39;</span><span class="p">)</span>

      <span class="n">arg_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>

      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">callee</span><span class="p">,</span> <span class="n">arg_values</span><span class="p">,</span> <span class="s">&#39;calltmp&#39;</span><span class="p">)</span>

<span class="c"># This class represents the &quot;prototype&quot; for a function, which captures its name,</span>
<span class="c"># and its argument names (thus implicitly the number of arguments the function</span>
<span class="c"># takes).</span>
<span class="k">class</span> <span class="nc">PrototypeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="c"># Make the function type, eg. double(double,double).</span>
      <span class="n">funct_type</span> <span class="o">=</span> <span class="n">Type</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
         <span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="p">[</span><span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">),</span> <span class="bp">False</span><span class="p">)</span>

      <span class="n">function</span> <span class="o">=</span> <span class="n">Function</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">g_llvm_module</span><span class="p">,</span> <span class="n">funct_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

      <span class="c"># If the name conflicted, there was already something with the same name.</span>
      <span class="c"># If it has a body, don&#39;t allow redefinition or reextern.</span>
      <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
         <span class="n">function</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
         <span class="n">function</span> <span class="o">=</span> <span class="n">g_llvm_module</span><span class="o">.</span><span class="n">get_function_named</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

         <span class="c"># If the function already has a body, reject this.</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">function</span><span class="o">.</span><span class="n">is_declaration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Redefinition of function.&#39;</span><span class="p">)</span>

         <span class="c"># If F took a different number of args, reject.</span>
         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">callee</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Redeclaration of a function with different number &#39;</span>
                               <span class="s">&#39;of args.&#39;</span><span class="p">)</span>

      <span class="c"># Set names for all arguments and add them to the variables symbol table.</span>
      <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">arg_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
         <span class="n">arg</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">arg_name</span>
         <span class="c"># Add arguments to variable symbol table.</span>
         <span class="n">g_named_values</span><span class="p">[</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>

      <span class="k">return</span> <span class="n">function</span>

<span class="c"># This class represents a function definition itself.</span>
<span class="k">class</span> <span class="nc">FunctionNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prototype</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="n">prototype</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="c"># Clear scope.</span>
      <span class="n">g_named_values</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

      <span class="c"># Create a function object.</span>
      <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>

      <span class="c"># Create a new basic block to start insertion into.</span>
      <span class="n">block</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">append_basic_block</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">)</span>
      <span class="k">global</span> <span class="n">g_llvm_builder</span>
      <span class="n">g_llvm_builder</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

      <span class="c"># Finish off the function.</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
         <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">ret</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span>

         <span class="c"># Validate the generated code, checking for consistency.</span>
         <span class="n">function</span><span class="o">.</span><span class="n">verify</span><span class="p">()</span>
      <span class="k">except</span><span class="p">:</span>
         <span class="n">function</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
         <span class="k">raise</span>

      <span class="k">return</span> <span class="n">function</span>
</pre></div>
</div>
</div>
<div class="section" id="parser">
<h3>3.6.4. Parser<a class="headerlink" href="#parser" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Parser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">binop_precedence</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">binop_precedence</span> <span class="o">=</span> <span class="n">binop_precedence</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

   <span class="c"># Provide a simple token buffer. Parser.current is the current token the</span>
   <span class="c"># parser is looking at. Parser.Next() reads another token from the lexer and</span>
   <span class="c"># updates Parser.current with its results.</span>
   <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>

   <span class="c"># Gets the precedence of the current token, or -1 if the token is not a binary</span>
   <span class="c"># operator.</span>
   <span class="k">def</span> <span class="nf">GetCurrentTokenPrecedence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">CharacterToken</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop_precedence</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">char</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

   <span class="c"># identifierexpr ::= identifier | identifier &#39;(&#39; expression* &#39;)&#39;</span>
   <span class="k">def</span> <span class="nf">ParseIdentifierExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">identifier_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">name</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat identifier.</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">):</span>  <span class="c"># Simple variable reference.</span>
         <span class="k">return</span> <span class="n">VariableExpressionNode</span><span class="p">(</span><span class="n">identifier_name</span><span class="p">)</span>

      <span class="c"># Call.</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;(&#39;.</span>
      <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">):</span>
         <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseExpression</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">==</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">):</span>
               <span class="k">break</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">):</span>
               <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected &quot;)&quot; or &quot;,&quot; in argument list.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;)&#39;.</span>
      <span class="k">return</span> <span class="n">CallExpressionNode</span><span class="p">(</span><span class="n">identifier_name</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

   <span class="c"># numberexpr ::= number</span>
   <span class="k">def</span> <span class="nf">ParseNumberExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">NumberExpressionNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># consume the number.</span>
      <span class="k">return</span> <span class="n">result</span>

   <span class="c"># parenexpr ::= &#39;(&#39; expression &#39;)&#39;</span>
   <span class="k">def</span> <span class="nf">ParseParenExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;(&#39;.</span>

      <span class="n">contents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseExpression</span><span class="p">()</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected &quot;)&quot;.&#39;</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;)&#39;.</span>

      <span class="k">return</span> <span class="n">contents</span>

   <span class="c"># primary ::= identifierexpr | numberexpr | parenexpr</span>
   <span class="k">def</span> <span class="nf">ParsePrimary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">IdentifierToken</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseIdentifierExpr</span><span class="p">()</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">NumberToken</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseNumberExpr</span><span class="p">()</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">==</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseParenExpr</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Unknown token when expecting an expression.&#39;</span><span class="p">)</span>

   <span class="c"># binoprhs ::= (operator primary)*</span>
   <span class="k">def</span> <span class="nf">ParseBinOpRHS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">left_precedence</span><span class="p">):</span>
      <span class="c"># If this is a binary operator, find its precedence.</span>
      <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
         <span class="n">precedence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetCurrentTokenPrecedence</span><span class="p">()</span>

         <span class="c"># If this is a binary operator that binds at least as tightly as the</span>
         <span class="c"># current one, consume it; otherwise we are done.</span>
         <span class="k">if</span> <span class="n">precedence</span> <span class="o">&lt;</span> <span class="n">left_precedence</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left</span>

         <span class="n">binary_operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">char</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat the operator.</span>

         <span class="c"># Parse the primary expression after the binary operator.</span>
         <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParsePrimary</span><span class="p">()</span>

         <span class="c"># If binary_operator binds less tightly with right than the operator after</span>
         <span class="c"># right, let the pending operator take right as its left.</span>
         <span class="n">next_precedence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetCurrentTokenPrecedence</span><span class="p">()</span>
         <span class="k">if</span> <span class="n">precedence</span> <span class="o">&lt;</span> <span class="n">next_precedence</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">precedence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

         <span class="c"># Merge left/right.</span>
         <span class="n">left</span> <span class="o">=</span> <span class="n">BinaryOperatorExpressionNode</span><span class="p">(</span><span class="n">binary_operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

   <span class="c"># expression ::= primary binoprhs</span>
   <span class="k">def</span> <span class="nf">ParseExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParsePrimary</span><span class="p">()</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

   <span class="c"># prototype ::= id &#39;(&#39; id* &#39;)&#39;</span>
   <span class="k">def</span> <span class="nf">ParsePrototype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">IdentifierToken</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected function name in prototype.&#39;</span><span class="p">)</span>

      <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">name</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat function name.</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected &quot;(&quot; in prototype.&#39;</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;(&#39;.</span>

      <span class="n">arg_names</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">IdentifierToken</span><span class="p">):</span>
         <span class="n">arg_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected &quot;)&quot; in prototype.&#39;</span><span class="p">)</span>

      <span class="c"># Success.</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;)&#39;.</span>

      <span class="k">return</span> <span class="n">PrototypeNode</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">arg_names</span><span class="p">)</span>

   <span class="c"># definition ::= &#39;def&#39; prototype expression</span>
   <span class="k">def</span> <span class="nf">ParseDefinition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat def.</span>
      <span class="n">proto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParsePrototype</span><span class="p">()</span>
      <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseExpression</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">FunctionNode</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>

   <span class="c"># toplevelexpr ::= expression</span>
   <span class="k">def</span> <span class="nf">ParseTopLevelExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">proto</span> <span class="o">=</span> <span class="n">PrototypeNode</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="p">[])</span>
      <span class="k">return</span> <span class="n">FunctionNode</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseExpression</span><span class="p">())</span>

   <span class="c"># external ::= &#39;extern&#39; prototype</span>
   <span class="k">def</span> <span class="nf">ParseExtern</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat extern.</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParsePrototype</span><span class="p">()</span>

   <span class="c"># Top-Level parsing</span>
   <span class="k">def</span> <span class="nf">HandleDefinition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseDefinition</span><span class="p">,</span> <span class="s">&#39;Read a function definition:&#39;</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">HandleExtern</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseExtern</span><span class="p">,</span> <span class="s">&#39;Read an extern:&#39;</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">HandleTopLevelExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseTopLevelExpr</span><span class="p">,</span> <span class="s">&#39;Read a top-level expression:&#39;</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">Handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="k">print</span> <span class="n">message</span><span class="p">,</span> <span class="n">function</span><span class="p">()</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
      <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
         <span class="k">print</span> <span class="s">&#39;Error:&#39;</span><span class="p">,</span> <span class="n">e</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span> <span class="c"># Skip for error recovery.</span>
         <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="main-driver-code">
<h3>3.6.5. Main driver code.<a class="headerlink" href="#main-driver-code" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
   <span class="c"># Install standard binary operators.</span>
   <span class="c"># 1 is lowest possible precedence. 40 is the highest.</span>
   <span class="n">operator_precedence</span> <span class="o">=</span> <span class="p">{</span>
   <span class="s">&#39;&lt;&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
   <span class="s">&#39;+&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
   <span class="s">&#39;-&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
   <span class="s">&#39;*&#39;</span><span class="p">:</span> <span class="mi">40</span>
   <span class="p">}</span>

   <span class="c"># Run the main &quot;interpreter loop&quot;.</span>
   <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;ready&gt;&#39;</span><span class="p">,</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">raw</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">()</span>
      <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
         <span class="k">break</span>

      <span class="n">parser</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">(</span><span class="n">Tokenize</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">operator_precedence</span><span class="p">)</span>
      <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
         <span class="c"># top ::= definition | external | expression | EOF</span>
         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">EOFToken</span><span class="p">):</span>
            <span class="k">break</span>
         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">DefToken</span><span class="p">):</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">HandleDefinition</span><span class="p">()</span>
         <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">ExternToken</span><span class="p">):</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">HandleExtern</span><span class="p">()</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">HandleTopLevelExpression</span><span class="p">()</span>

   <span class="c"># Print out all of the generated code.</span>
   <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">g_llvm_module</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
   <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Chapter 3: Code generation to LLVM IR</a><ul>
<li><a class="reference internal" href="#introduction">3.1. Introduction</a></li>
<li><a class="reference internal" href="#code-generation-setup">3.2. Code Generation Setup</a></li>
<li><a class="reference internal" href="#expression-code-generation">3.3. Expression Code Generation</a></li>
<li><a class="reference internal" href="#function-code-generation">3.4. Function Code Generation</a></li>
<li><a class="reference internal" href="#driver-changes-and-closing-thoughts">3.5. Driver Changes and Closing Thoughts</a></li>
<li><a class="reference internal" href="#full-code-listing">3.6. Full Code Listing</a><ul>
<li><a class="reference internal" href="#globals">3.6.1. Globals</a></li>
<li><a class="reference internal" href="#lexer">3.6.2. Lexer</a></li>
<li><a class="reference internal" href="#abstract-syntax-tree-aka-parse-tree">3.6.3. Abstract Syntax Tree (aka Parse Tree)</a></li>
<li><a class="reference internal" href="#parser">3.6.4. Parser</a></li>
<li><a class="reference internal" href="#main-driver-code">3.6.5. Main driver code.</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="PythonLangImpl2.html"
                        title="previous chapter">2. Chapter 2: Implementing a Parser and AST</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="PythonLangImpl4.html"
                        title="next chapter">4. Chapter 4: Adding JIT and Optimizer Support</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/doc/kaleidoscope/PythonLangImpl3.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl4.html" title="4. Chapter 4: Adding JIT and Optimizer Support"
             >next</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl2.html" title="2. Chapter 2: Implementing a Parser and AST"
             >previous</a> |</li>
        <li><a href="../../index.html">llvmpy 0.9.0 documentation</a> &raquo;</li>
          <li><a href="../examples.html" >Examples and LLVM Tutorials</a> &raquo;</li>
          <li><a href="index.html" >Kaleidoscope</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Mahadevan R (2008-2010), Continuum Analytics (2012).
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>