

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>4. Chapter 4: Adding JIT and Optimizer Support &mdash; llvmpy 0.9.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="llvmpy 0.9.0 documentation" href="../../index.html" />
    <link rel="up" title="Kaleidoscope" href="index.html" />
    <link rel="next" title="5. Chapter 5: Extending the Language: Control Flow" href="PythonLangImpl5.html" />
    <link rel="prev" title="3. Chapter 3: Code generation to LLVM IR" href="PythonLangImpl3.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl5.html" title="5. Chapter 5: Extending the Language: Control Flow"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl3.html" title="3. Chapter 3: Code generation to LLVM IR"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">llvmpy 0.9.0 documentation</a> &raquo;</li>
          <li><a href="../examples.html" >Examples and LLVM Tutorials</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Kaleidoscope</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-4-adding-jit-and-optimizer-support">
<h1>4. Chapter 4: Adding JIT and Optimizer Support<a class="headerlink" href="#chapter-4-adding-jit-and-optimizer-support" title="Permalink to this headline">¶</a></h1>
<p>Written by <a class="reference external" href="mailto:sabre&#37;&#52;&#48;nondot&#46;org">Chris Lattner</a> and <a class="reference external" href="http://max99x.com">Max
Shawabkeh</a></p>
<div class="section" id="introduction">
<h2>4.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Welcome to Chapter 4 of the <a class="reference external" href="http://www.llvm.org/docs/tutorial/index.html">Implementing a language with
LLVM</a> tutorial. Chapters
1-3 described the implementation of a simple language and added support
for generating LLVM IR. This chapter describes two new techniques:
adding optimizer support to your language, and adding JIT compiler
support. These additions will demonstrate how to get nice, efficient
code for the Kaleidoscope language.</p>
</div>
<hr class="docutils" />
<div class="section" id="trivial-constant-folding">
<h2>4.2. Trivial Constant Folding<a class="headerlink" href="#trivial-constant-folding" title="Permalink to this headline">¶</a></h2>
<p>Our demonstration for Chapter 3 is elegant and easy to extend.
Unfortunately, it does not produce wonderful code. The LLVM Builder,
however, does give us obvious optimizations when compiling simple code:</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def <span class="nb">test</span><span class="o">(</span>x<span class="o">)</span> 1+2+x
Read <span class="k">function </span>definition:
define double @test<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span>
entry:
   %addtmp <span class="o">=</span> fadd double 3.000000e+00, %x
   ret double %addtmp
<span class="o">}</span>
</pre></div>
</div>
<p>This code is not a literal transcription of the AST built by parsing the
input. That would be:</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def <span class="nb">test</span><span class="o">(</span>x<span class="o">)</span> 1+2+x
Read <span class="k">function </span>definition:
define double @test<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span>
   entry:
   %addtmp <span class="o">=</span> fadd double 2.000000e+00, 1.000000e+00
   %addtmp1 <span class="o">=</span> fadd double %addtmp, %x
   ret double %addtmp1
<span class="o">}</span>
</pre></div>
</div>
<p>Constant folding, as seen above, in particular, is a very common and
very important optimization: so much so that many language implementors
implement constant folding support in their AST representation.</p>
<p>With LLVM, you don&#8217;t need this support in the AST. Since all calls to
build LLVM IR go through the LLVM IR builder, the builder itself checked
to see if there was a constant folding opportunity when you call it. If
so, it just does the constant fold and return the constant instead of
creating an instruction.</p>
<p>Well, that was easy :). In practice, we recommend always using
<tt class="docutils literal"><span class="pre">llvm.core.Builder</span></tt> when generating code like this. It has no
&#8220;syntactic overhead&#8221; for its use (you don&#8217;t have to uglify your compiler
with constant checks everywhere) and it can dramatically reduce the
amount of LLVM IR that is generated in some cases (particular for
languages with a macro preprocessor or that use a lot of constants).</p>
<p>On the other hand, the <tt class="docutils literal"><span class="pre">Builder</span></tt> is limited by the fact that it does
all of its analysis inline with the code as it is built. If you take a
slightly more complex example:</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def <span class="nb">test</span><span class="o">(</span>x<span class="o">)</span> <span class="o">(</span>1+2+x<span class="o">)</span>*<span class="o">(</span>x+<span class="o">(</span>1+2<span class="o">))</span>
Read a <span class="k">function </span>definition:
define double @test<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span>
entry:
   %addtmp <span class="o">=</span> fadd double 3.000000e+00, %x   ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %addtmp1 <span class="o">=</span> fadd double %x, 3.000000e+00  ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %multmp <span class="o">=</span> fmul double %addtmp, %addtmp1  ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %multmp
<span class="o">}</span>
</pre></div>
</div>
<p>In this case, the LHS and RHS of the multiplication are the same value.
We&#8217;d really like to see this generate&#8221;<tt class="docutils literal"><span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">x+3;</span> <span class="pre">result</span> <span class="pre">=</span> <span class="pre">tmp*tmp;</span></tt>
instead of computing <tt class="docutils literal"><span class="pre">x+3</span></tt> twice.</p>
<p>Unfortunately, no amount of local analysis will be able to detect and
correct this. This requires two transformations: reassociation of
expressions (to make the add&#8217;s lexically identical) and Common
Subexpression Elimination (CSE) to delete the redundant add instruction.
Fortunately, LLVM provides a broad range of optimizations that you can
use, in the form of &#8220;passes&#8221;.</p>
</div>
<hr class="docutils" />
<div class="section" id="llvm-optimization-passes">
<h2>4.3. LLVM Optimization Passes<a class="headerlink" href="#llvm-optimization-passes" title="Permalink to this headline">¶</a></h2>
<p>LLVM provides many optimization passes, which do many different sorts of
things and have different tradeoffs. Unlike other systems, LLVM doesn&#8217;t
hold to the mistaken notion that one set of optimizations is right for
all languages and for all situations. LLVM allows a compiler implementor
to make complete decisions about what optimizations to use, in which
order, and in what situation.</p>
<p>As a concrete example, LLVM supports both &#8220;whole module&#8221; passes, which
look across as large of body of code as they can (often a whole file,
but if run at link time, this can be a substantial portion of the whole
program). It also supports and includes &#8220;per-function&#8221; passes which just
operate on a single function at a time, without looking at other
functions. For more information on passes and how they are run, see the
<a class="reference external" href="http://www.llvm.org/docs/WritingAnLLVMPass.html">How to Write a Pass</a>
document and the <a class="reference external" href="http://www.llvm.org/docs/Passes.html">List of LLVM
Passes</a>.</p>
<p>For Kaleidoscope, we are currently generating functions on the fly, one
at a time, as the user types them in. We aren&#8217;t shooting for the
ultimate optimization experience in this setting, but we also want to
catch the easy and quick stuff where possible. As such, we will choose
to run a few per-function optimizations as the user types the function
in. If we wanted to make a &#8220;static Kaleidoscope compiler&#8221;, we would use
exactly the code we have now, except that we would defer running the
optimizer until the entire file has been parsed.</p>
<p>In order to get per-function optimizations going, we need to set up a
<a class="reference external" href="http://www.llvm.org/docs/WritingAnLLVMPass.html#passmanager">FunctionPassManager</a>
to hold and organize the LLVM optimizations that we want to run. Once we
have that, we can add a set of optimizations to run. The code looks like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The function optimization passes manager.</span>
<span class="n">g_llvm_pass_manager</span> <span class="o">=</span> <span class="n">FunctionPassManager</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">g_llvm_module</span><span class="p">)</span>

<span class="c"># The LLVM execution engine.</span>
<span class="n">g_llvm_executor</span> <span class="o">=</span> <span class="n">ExecutionEngine</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">g_llvm_module</span><span class="p">)</span>

<span class="o">...</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
   <span class="c"># Set up the optimizer pipeline. Start with registering info about how the</span>
   <span class="c"># target lays out data structures.</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g_llvm_executor</span><span class="o">.</span><span class="n">target_data</span><span class="p">)</span>
   <span class="c"># Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PASS_INSTRUCTION_COMBINING</span><span class="p">)</span>
   <span class="c"># Reassociate expressions.</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PASS_REASSOCIATE</span><span class="p">)</span>
   <span class="c"># Eliminate Common SubExpressions.</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PASS_GVN</span><span class="p">)</span>
   <span class="c"># Simplify the control flow graph (deleting unreachable blocks, etc).</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PASS_CFG_SIMPLIFICATION</span><span class="p">)</span>

   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
</pre></div>
</div>
<p>This code defines a <tt class="docutils literal"><span class="pre">FunctionPassManager</span></tt>, <tt class="docutils literal"><span class="pre">g_llvm_pass_manager</span></tt>.
Once it is set up, we use a series of &#8220;add&#8221; calls to add a bunch of LLVM
passes. The first pass is basically boilerplate, it adds a pass so that
later optimizations know how the data structures in the program are laid
out. (The &#8220;<tt class="docutils literal"><span class="pre">g_llvm_executor</span></tt>&#8221; variable is related to the JIT, which
we will get to in the next section.) In this case, we choose to add 4
optimization passes. The passes we chose here are a pretty standard set
of &#8220;cleanup&#8221; optimizations that are useful for a wide variety of code. I
won&#8217;t delve into what they do but, believe me, they are a good starting
place :).</p>
<p>Once the pass manager is set up, we need to make use of it. We do this
by running it after our newly created function is constructed (in
<tt class="docutils literal"><span class="pre">FunctionNode.CodeGen</span></tt>), but before it is returned to the client:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
<span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">ret</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span>

<span class="c"># Validate the generated code, checking for consistency.</span>
<span class="n">function</span><span class="o">.</span><span class="n">verify</span><span class="p">()</span>

<span class="c"># Optimize the function.</span>
<span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
</pre></div>
</div>
<p>As you can see, this is pretty straightforward. The
<tt class="docutils literal"><span class="pre">FunctionPassManager</span></tt> optimizes and updates the LLVM Function in
place, improving (hopefully) its body. With this in place, we can try
our test above again:</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def <span class="nb">test</span><span class="o">(</span>x<span class="o">)</span> <span class="o">(</span>1+2+x<span class="o">)</span>*<span class="o">(</span>x+<span class="o">(</span>1+2<span class="o">))</span>
Read a <span class="k">function </span>definition:
define double @test<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span>
entry:
   %addtmp <span class="o">=</span> fadd double %x, 3.000000e+00 ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=2]</span>
   %multmp <span class="o">=</span> fmul double %addtmp, %addtmp ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %multmp
<span class="o">}</span>
</pre></div>
</div>
<p>As expected, we now get our nicely optimized code, saving a floating
point add instruction from every execution of this function.</p>
<p>LLVM provides a wide variety of optimizations that can be used in
certain circumstances. Some <a class="reference external" href="http://www.llvm.org/docs/Passes.html">documentation about the various
passes</a> is available, but it
isn&#8217;t very complete. Another good source of ideas can come from looking
at the passes that <tt class="docutils literal"><span class="pre">llvm-gcc</span></tt> or <tt class="docutils literal"><span class="pre">llvm-ld</span></tt> run to get started. The
<tt class="docutils literal"><span class="pre">opt</span></tt> tool allows you to experiment with passes from the command line,
so you can see if they do anything.</p>
<p>Now that we have reasonable code coming out of our front-end, lets talk
about executing it!</p>
</div>
<hr class="docutils" />
<div class="section" id="adding-a-jit-compiler">
<h2>4.4. Adding a JIT Compiler<a class="headerlink" href="#adding-a-jit-compiler" title="Permalink to this headline">¶</a></h2>
<p>Code that is available in LLVM IR can have a wide variety of tools
applied to it. For example, you can run optimizations on it (as we did
above), you can dump it out in textual or binary forms, you can compile
the code to an assembly file (.s) for some target, or you can JIT
compile it. The nice thing about the LLVM IR representation is that it
is the &#8220;common currency&#8221; between many different parts of the compiler.</p>
<p>In this section, we&#8217;ll add JIT compiler support to our interpreter. The
basic idea that we want for Kaleidoscope is to have the user enter
function bodies as they do now, but immediately evaluate the top-level
expressions they type in. For example, if they type in &#8220;1 + 2&#8221;, we
should evaluate and print out 3. If they define a function, they should
be able to call it from the command line.</p>
<p>In order to do this, we first declare and initialize the JIT. This is
done by adding and initializing a global variable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The LLVM execution engine.</span>
<span class="n">g_llvm_executor</span> <span class="o">=</span> <span class="n">ExecutionEngine</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">g_llvm_module</span><span class="p">)</span>
</pre></div>
</div>
<p>This creates an abstract &#8220;Execution Engine&#8221; which can be either a JIT
compiler or the LLVM interpreter. LLVM will automatically pick a JIT
compiler for you if one is available for your platform, otherwise it
will fall back to the interpreter.</p>
<p>Once the <tt class="docutils literal"><span class="pre">ExecutionEngine</span></tt> is created, the JIT is ready to be used. We
can use the <tt class="docutils literal"><span class="pre">run_function</span></tt> method of the execution engine to execute a
compiled function and get its return value. In our case, this means that
we can change the code that parses a top-level expression to look like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">HandleTopLevelExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="k">try</span><span class="p">:</span>
      <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseTopLevelExpr</span><span class="p">()</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">g_llvm_executor</span><span class="o">.</span><span class="n">run_function</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="p">[])</span>
      <span class="k">print</span> <span class="s">&#39;Evaluated to:&#39;</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">as_real</span><span class="p">(</span><span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">())</span>
   <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;Error:&#39;</span><span class="p">,</span> <span class="n">e</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span> <span class="c"># Skip for error recovery.</span>
      <span class="k">except</span><span class="p">:</span>
         <span class="k">pass</span>
</pre></div>
</div>
<p>Recall that we compile top-level expressions into a self-contained LLVM
function that takes no arguments and returns the computed double.</p>
<p>With just these two changes, lets see how Kaleidoscope works now!</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; 4+5
Read a top level expression:
define double @0<span class="o">()</span> <span class="o">{</span>
entry:
   ret double 9.000000e+00
<span class="o">}</span>

Evaluated to: 9.0
</pre></div>
</div>
<p>Well this looks like it is basically working. The dump of the function
shows the &#8220;no argument function that always returns double&#8221; that we
synthesize for each top-level expression that is typed in. This
demonstrates very basic functionality, but can we do more?</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; def testfunc<span class="o">(</span>x y<span class="o">)</span> x + y*2
Read a <span class="k">function </span>definition:
define double @testfunc<span class="o">(</span>double %x, double %y<span class="o">)</span> <span class="o">{</span>
entry:
   %multmp <span class="o">=</span> fmul double %y, 2.000000e+00 ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %addtmp <span class="o">=</span> fadd double %multmp, %x ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %addtmp
<span class="o">}</span>

ready&gt; testfunc<span class="o">(</span>4, 10<span class="o">)</span>
Read a top level expression:
define double @0<span class="o">()</span> <span class="o">{</span>
entry:
   %calltmp <span class="o">=</span> call double @testfunc<span class="o">(</span>double 4.000000e+00, double 1.000000e+01<span class="o">)</span> ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %calltmp
<span class="o">}</span>

*Evaluated to: 24.0*
</pre></div>
</div>
<p>This illustrates that we can now call user code, but there is something
a bit subtle going on here. Note that we only invoke the JIT on the
anonymous functions that <em>call testfunc</em>, but we never invoked it on
<em>testfunc</em> itself. What actually happened here is that the JIT scanned
for all non-JIT&#8217;d functions transitively called from the anonymous
function and compiled all of them before returning from
<tt class="docutils literal"><span class="pre">run_function()</span></tt>.</p>
<p>The JIT provides a number of other more advanced interfaces for things
like freeing allocated machine code, rejit&#8217;ing functions to update them,
etc. However, even with this simple code, we get some surprisingly
powerful capabilities - check this out (I removed the dump of the
anonymous functions, you should get the idea by now :) :</p>
<div class="highlight-bash"><div class="highlight"><pre>ready&gt; extern sin<span class="o">(</span>x<span class="o">)</span>
Read an extern:
<span class="nb">declare </span>double @sin<span class="o">(</span>double<span class="o">)</span>

ready&gt; extern cos<span class="o">(</span>x<span class="o">)</span>
Read an extern:
<span class="nb">declare </span>double @cos<span class="o">(</span>double<span class="o">)</span>

ready&gt; sin<span class="o">(</span>1.0<span class="o">)</span>
*Evaluated to: 0.841470984808*

ready&gt; def foo<span class="o">(</span>x<span class="o">)</span> sin<span class="o">(</span>x<span class="o">)</span> *sin<span class="o">(</span>x<span class="o">)</span> + cos<span class="o">(</span>x<span class="o">)</span>* cos<span class="o">(</span>x<span class="o">)</span>
Read a <span class="k">function </span>definition:
define double @foo<span class="o">(</span>double %x<span class="o">)</span> <span class="o">{</span>
entry:
   %calltmp <span class="o">=</span> call double @sin<span class="o">(</span>double %x<span class="o">)</span>      ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %calltmp1 <span class="o">=</span> call double @sin<span class="o">(</span>double %x<span class="o">)</span>     ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %multmp <span class="o">=</span> fmul double %calltmp, %calltmp1   ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %calltmp2 <span class="o">=</span> call double @cos<span class="o">(</span>double %x<span class="o">)</span>     ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %calltmp3 <span class="o">=</span> call double @cos<span class="o">(</span>double %x<span class="o">)</span>     ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %multmp4 <span class="o">=</span> fmul double %calltmp2, %calltmp3 ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   %addtmp <span class="o">=</span> fadd double %multmp, %multmp4     ; &lt;double&gt; <span class="o">[</span><span class="c">#uses=1]</span>
   ret double %addtmp
<span class="o">}</span>

ready&gt; foo<span class="o">(</span>4.0<span class="o">)</span>
*Evaluated to: 1.000000*
</pre></div>
</div>
<p>Whoa, how does the JIT know about sin and cos? The answer is
surprisingly simple: in this example, the JIT started execution of a
function and got to a function call. It realized that the function was
not yet JIT compiled and invoked the standard set of routines to resolve
the function. In this case, there is no body defined for the function,
so the JIT ended up calling <tt class="docutils literal"><span class="pre">dlsym(&quot;sin&quot;)</span></tt> on the Python process that
is hosting our Kaleidoscope prompt. Since <tt class="docutils literal"><span class="pre">sin</span></tt> is defined within the
JIT&#8217;s address space, it simply patches up calls in the module to call
the libm version of <tt class="docutils literal"><span class="pre">sin</span></tt> directly.</p>
<p>One interesting application of this is that we can now extend the
language by writing arbitrary C++ code to implement operations. For
example, we can create a C file with the following simple function:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">double</span> <span class="nf">putchard</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">putchar</span><span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="n">x</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can then compile this into a shared library with GCC:</p>
<div class="highlight-python"><pre>gcc -shared -fPIC -o putchard.so putchard.c</pre>
</div>
<p>Now we can load this library into the Python process using
<tt class="docutils literal"><span class="pre">llvm.core.load_library_permanently</span></tt> and access it from Kaleidoscope
to produce simple output to the console:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">llvm.core</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">llvm</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">load_library_permanently</span><span class="p">(</span><span class="s">&#39;/home/max/llvmpy-tutorial/putchard.so&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">kaleidoscope</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kaleidoscope</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
<span class="go">ready&gt; extern putchard(x)</span>
<span class="go">Read an extern:</span>
<span class="go">declare double @putchard(double)</span>

<span class="go">ready&gt; putchard(65) + putchard(66) + putchard(67) + putchard(10)</span>
<span class="go">*ABC*</span>
<span class="go">Evaluated to: 0.0</span>
</pre></div>
</div>
<p>Similar code could be used to implement file I/O, console input, and
many other capabilities in Kaleidoscope.</p>
<p>This completes the JIT and optimizer chapter of the Kaleidoscope
tutorial. At this point, we can compile a non-Turing-complete
programming language, optimize and JIT compile it in a user-driven way.
Next up we&#8217;ll look into <a class="reference external" href="PythonLangImpl5.html">extending the language with control flow
constructs</a>, tackling some interesting LLVM IR
issues along the way.</p>
</div>
<hr class="docutils" />
<div class="section" id="full-code-listing">
<h2>4.5. Full Code Listing<a class="headerlink" href="#full-code-listing" title="Permalink to this headline">¶</a></h2>
<p>Here is the complete code listing for our running example, enhanced with
the LLVM JIT and optimizer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">llvm.core</span> <span class="kn">import</span> <span class="n">Module</span><span class="p">,</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Builder</span><span class="p">,</span> <span class="n">FCMP_ULT</span>
<span class="kn">from</span> <span class="nn">llvm.ee</span> <span class="kn">import</span> <span class="n">ExecutionEngine</span><span class="p">,</span> <span class="n">TargetData</span>
<span class="kn">from</span> <span class="nn">llvm.passes</span> <span class="kn">import</span> <span class="n">FunctionPassManager</span>
<span class="kn">from</span> <span class="nn">llvm.passes</span> <span class="kn">import</span> <span class="p">(</span><span class="n">PASS_INSTRUCTION_COMBINING</span><span class="p">,</span>
                         <span class="n">PASS_REASSOCIATE</span><span class="p">,</span>
                         <span class="n">PASS_GVN</span><span class="p">,</span>
                         <span class="n">PASS_CFG_SIMPLIFICATION</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="globals">
<h3>4.5.1. Globals<a class="headerlink" href="#globals" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The LLVM module, which holds all the IR code.</span>
<span class="n">g_llvm_module</span> <span class="o">=</span> <span class="n">Module</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s">&#39;my cool jit&#39;</span><span class="p">)</span>

<span class="c"># The LLVM instruction builder. Created whenever a new function is entered.</span>
<span class="n">g_llvm_builder</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c"># A dictionary that keeps track of which values are defined in the current scope</span>
<span class="c"># and what their LLVM representation is.</span>
<span class="n">g_named_values</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c"># The function optimization passes manager.</span>
<span class="n">g_llvm_pass_manager</span> <span class="o">=</span> <span class="n">FunctionPassManager</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">g_llvm_module</span><span class="p">)</span>

<span class="c"># The LLVM execution engine.</span>
<span class="n">g_llvm_executor</span> <span class="o">=</span> <span class="n">ExecutionEngine</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">g_llvm_module</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="lexer">
<h3>4.5.2. Lexer<a class="headerlink" href="#lexer" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The lexer yields one of these types for each token.</span>
<span class="k">class</span> <span class="nc">EOFToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">pass</span>

<span class="k">class</span> <span class="nc">DefToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ExternToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">pass</span>

<span class="k">class</span> <span class="nc">IdentifierToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="k">class</span> <span class="nc">NumberToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">CharacterToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">char</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">char</span> <span class="o">=</span> <span class="n">char</span>
   <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CharacterToken</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">char</span>
   <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
      <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<span class="c"># Regular expressions that tokens and comments of our language.</span>
<span class="n">REGEX_NUMBER</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;[0-9]+(?:\.[0-9]+)?&#39;</span><span class="p">)</span>
<span class="n">REGEX_IDENTIFIER</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;[a-zA-Z][a-zA-Z0-9]*&#39;</span><span class="p">)</span>
<span class="n">REGEX_COMMENT</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;#.*&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Tokenize</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
   <span class="k">while</span> <span class="n">string</span><span class="p">:</span>
      <span class="c"># Skip whitespace.</span>
      <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
         <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
         <span class="k">continue</span>

      <span class="c"># Run regexes.</span>
      <span class="n">comment_match</span> <span class="o">=</span> <span class="n">REGEX_COMMENT</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
      <span class="n">number_match</span> <span class="o">=</span> <span class="n">REGEX_NUMBER</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
      <span class="n">identifier_match</span> <span class="o">=</span> <span class="n">REGEX_IDENTIFIER</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>

      <span class="c"># Check if any of the regexes matched and yield the appropriate result.</span>
      <span class="k">if</span> <span class="n">comment_match</span><span class="p">:</span>
         <span class="n">comment</span> <span class="o">=</span> <span class="n">comment_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
         <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">comment</span><span class="p">):]</span>
      <span class="k">elif</span> <span class="n">number_match</span><span class="p">:</span>
         <span class="n">number</span> <span class="o">=</span> <span class="n">number_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
         <span class="k">yield</span> <span class="n">NumberToken</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>
         <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">number</span><span class="p">):]</span>
      <span class="k">elif</span> <span class="n">identifier_match</span><span class="p">:</span>
         <span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
         <span class="c"># Check if we matched a keyword.</span>
         <span class="k">if</span> <span class="n">identifier</span> <span class="o">==</span> <span class="s">&#39;def&#39;</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">DefToken</span><span class="p">()</span>
         <span class="k">elif</span> <span class="n">identifier</span> <span class="o">==</span> <span class="s">&#39;extern&#39;</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">ExternToken</span><span class="p">()</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">IdentifierToken</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span>
         <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">identifier</span><span class="p">):]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="c"># Yield the ASCII value of the unknown character.</span>
         <span class="k">yield</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
         <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

<span class="k">yield</span> <span class="n">EOFToken</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="abstract-syntax-tree-aka-parse-tree">
<h3>4.5.3. Abstract Syntax Tree (aka Parse Tree)<a class="headerlink" href="#abstract-syntax-tree-aka-parse-tree" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Base class for all expression nodes.</span>
<span class="k">class</span> <span class="nc">ExpressionNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="k">pass</span>

<span class="c"># Expression class for numeric literals like &quot;1.0&quot;.</span>
<span class="k">class</span> <span class="nc">NumberExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Constant</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<span class="c"># Expression class for referencing a variable, like &quot;a&quot;.</span>
<span class="k">class</span> <span class="nc">VariableExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">g_named_values</span><span class="p">:</span>
         <span class="k">return</span> <span class="n">g_named_values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Unknown variable name: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="c"># Expression class for a binary operator.</span>
<span class="k">class</span> <span class="nc">BinaryOperatorExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
      <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>

   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;+&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fadd</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;addtmp&#39;</span><span class="p">)</span>
   <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fsub</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;subtmp&#39;</span><span class="p">)</span>
   <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;*&#39;</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fmul</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;multmp&#39;</span><span class="p">)</span>
   <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">fcmp</span><span class="p">(</span><span class="n">FCMP_ULT</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s">&#39;cmptmp&#39;</span><span class="p">)</span>
      <span class="c"># Convert bool 0 or 1 to double 0.0 or 1.0.</span>
      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">uitofp</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="s">&#39;booltmp&#39;</span><span class="p">)</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Unknown binary operator.&#39;</span><span class="p">)</span>

<span class="c"># Expression class for function calls.</span>
<span class="k">class</span> <span class="nc">CallExpressionNode</span><span class="p">(</span><span class="n">ExpressionNode</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callee</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">callee</span> <span class="o">=</span> <span class="n">callee</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="c"># Look up the name in the global module table.</span>
      <span class="n">callee</span> <span class="o">=</span> <span class="n">g_llvm_module</span><span class="o">.</span><span class="n">get_function_named</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>

      <span class="c"># Check for argument mismatch error.</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">callee</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Incorrect number of arguments passed.&#39;</span><span class="p">)</span>

      <span class="n">arg_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>

      <span class="k">return</span> <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">callee</span><span class="p">,</span> <span class="n">arg_values</span><span class="p">,</span> <span class="s">&#39;calltmp&#39;</span><span class="p">)</span>

<span class="c"># This class represents the &quot;prototype&quot; for a function, which captures its name,</span>
<span class="c"># and its argument names (thus implicitly the number of arguments the function</span>
<span class="c"># takes).</span>
<span class="k">class</span> <span class="nc">PrototypeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="c"># Make the function type, eg. double(double,double).</span>
      <span class="n">funct_type</span> <span class="o">=</span> <span class="n">Type</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
         <span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span> <span class="p">[</span><span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">),</span> <span class="bp">False</span><span class="p">)</span>

   <span class="n">function</span> <span class="o">=</span> <span class="n">Function</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">g_llvm_module</span><span class="p">,</span> <span class="n">funct_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

   <span class="c"># If the name conflicted, there was already something with the same name.</span>
   <span class="c"># If it has a body, don&#39;t allow redefinition or reextern.</span>
   <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
      <span class="n">function</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
      <span class="n">function</span> <span class="o">=</span> <span class="n">g_llvm_module</span><span class="o">.</span><span class="n">get_function_named</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

      <span class="c"># If the function already has a body, reject this.</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">function</span><span class="o">.</span><span class="n">is_declaration</span><span class="p">:</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Redefinition of function.&#39;</span><span class="p">)</span>

      <span class="c"># If F took a different number of args, reject.</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">callee</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Redeclaration of a function with different number &#39;</span>
                            <span class="s">&#39;of args.&#39;</span><span class="p">)</span>

   <span class="c"># Set names for all arguments and add them to the variables symbol table.</span>
   <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">arg_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
      <span class="n">arg</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">arg_name</span>
      <span class="c"># Add arguments to variable symbol table.</span>
      <span class="n">g_named_values</span><span class="p">[</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>

   <span class="k">return</span> <span class="n">function</span>

<span class="c"># This class represents a function definition itself.</span>
<span class="k">class</span> <span class="nc">FunctionNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prototype</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="n">prototype</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>

   <span class="k">def</span> <span class="nf">CodeGen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="c"># Clear scope.</span>
      <span class="n">g_named_values</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

      <span class="c"># Create a function object.</span>
      <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>

      <span class="c"># Create a new basic block to start insertion into.</span>
      <span class="n">block</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">append_basic_block</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">)</span>
      <span class="k">global</span> <span class="n">g_llvm_builder</span>
      <span class="n">g_llvm_builder</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

      <span class="c"># Finish off the function.</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
         <span class="n">g_llvm_builder</span><span class="o">.</span><span class="n">ret</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span>

         <span class="c"># Validate the generated code, checking for consistency.</span>
         <span class="n">function</span><span class="o">.</span><span class="n">verify</span><span class="p">()</span>

         <span class="c"># Optimize the function.</span>
         <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
      <span class="k">except</span><span class="p">:</span>
         <span class="n">function</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
         <span class="k">raise</span>

      <span class="k">return</span> <span class="n">function</span>
</pre></div>
</div>
</div>
<div class="section" id="parser">
<h3>4.5.4. Parser<a class="headerlink" href="#parser" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Parser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">binop_precedence</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">binop_precedence</span> <span class="o">=</span> <span class="n">binop_precedence</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

   <span class="c"># Provide a simple token buffer. Parser.current is the current token the</span>
   <span class="c"># parser is looking at. Parser.Next() reads another token from the lexer and</span>
   <span class="c"># updates Parser.current with its results.</span>
   <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>

   <span class="c"># Gets the precedence of the current token, or -1 if the token is not a</span>
   <span class="n">binary</span> <span class="c"># operator.</span>
   <span class="k">def</span> <span class="nf">GetCurrentTokenPrecedence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">CharacterToken</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop_precedence</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">char</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
         <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

   <span class="c"># identifierexpr ::= identifier | identifier &#39;(&#39; expression* &#39;)&#39;</span>
      <span class="k">def</span> <span class="nf">ParseIdentifierExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="n">identifier_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">name</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat identifier.</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">):</span>  <span class="c"># Simple variable reference.</span>
         <span class="k">return</span> <span class="n">VariableExpressionNode</span><span class="p">(</span><span class="n">identifier_name</span><span class="p">)</span>

      <span class="c"># Call.</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;(&#39;.</span>
      <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">):</span>
         <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseExpression</span><span class="p">())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">==</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">):</span>
               <span class="k">break</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">):</span>
               <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected &quot;)&quot; or &quot;,&quot; in argument list.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;)&#39;.</span>
      <span class="k">return</span> <span class="n">CallExpressionNode</span><span class="p">(</span><span class="n">identifier_name</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

   <span class="c"># numberexpr ::= number</span>
   <span class="k">def</span> <span class="nf">ParseNumberExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">NumberExpressionNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span> <span class="c"># consume the number.</span>
      <span class="k">return</span> <span class="n">result</span>

   <span class="c"># parenexpr ::= &#39;(&#39; expression &#39;)&#39;</span>
   <span class="k">def</span> <span class="nf">ParseParenExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;(&#39;.</span>

      <span class="n">contents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseExpression</span><span class="p">()</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected &quot;)&quot;.&#39;</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;)&#39;.</span>

      <span class="k">return</span> <span class="n">contents</span>

   <span class="c"># primary ::= identifierexpr | numberexpr | parenexpr</span>
   <span class="k">def</span> <span class="nf">ParsePrimary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">IdentifierToken</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseIdentifierExpr</span><span class="p">()</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">NumberToken</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseNumberExpr</span><span class="p">()</span>
      <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">==</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseParenExpr</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Unknown token when expecting an expression.&#39;</span><span class="p">)</span>

   <span class="c"># binoprhs ::= (operator primary)*</span>
   <span class="k">def</span> <span class="nf">ParseBinOpRHS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">left_precedence</span><span class="p">):</span>
      <span class="c"># If this is a binary operator, find its precedence.</span>
      <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
         <span class="n">precedence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetCurrentTokenPrecedence</span><span class="p">()</span>

         <span class="c"># If this is a binary operator that binds at least as tightly as the</span>
         <span class="c"># current one, consume it; otherwise we are done.</span>
         <span class="k">if</span> <span class="n">precedence</span> <span class="o">&lt;</span> <span class="n">left_precedence</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left</span>

         <span class="n">binary_operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">char</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat the operator.</span>

         <span class="c"># Parse the primary expression after the binary operator.</span>
         <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParsePrimary</span><span class="p">()</span>

         <span class="c"># If binary_operator binds less tightly with right than the operator after</span>
         <span class="c"># right, let the pending operator take right as its left.</span>
         <span class="n">next_precedence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetCurrentTokenPrecedence</span><span class="p">()</span>
         <span class="k">if</span> <span class="n">precedence</span> <span class="o">&lt;</span> <span class="n">next_precedence</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">precedence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

         <span class="c"># Merge left/right.</span>
         <span class="n">left</span> <span class="o">=</span> <span class="n">BinaryOperatorExpressionNode</span><span class="p">(</span><span class="n">binary_operator</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

   <span class="c"># expression ::= primary binoprhs</span>
   <span class="k">def</span> <span class="nf">ParseExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParsePrimary</span><span class="p">()</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

   <span class="c"># prototype ::= id &#39;(&#39; id* &#39;)&#39;</span>
   <span class="k">def</span> <span class="nf">ParsePrototype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">IdentifierToken</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected function name in prototype.&#39;</span><span class="p">)</span>

      <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">name</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat function name.</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected &quot;(&quot; in prototype.&#39;</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;(&#39;.</span>

      <span class="n">arg_names</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">IdentifierToken</span><span class="p">):</span>
         <span class="n">arg_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">!=</span> <span class="n">CharacterToken</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">):</span>
         <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Expected &quot;)&quot; in prototype.&#39;</span><span class="p">)</span>

      <span class="c"># Success.</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat &#39;)&#39;.</span>

      <span class="k">return</span> <span class="n">PrototypeNode</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">arg_names</span><span class="p">)</span>

   <span class="c"># definition ::= &#39;def&#39; prototype expression</span>
   <span class="k">def</span> <span class="nf">ParseDefinition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span> <span class="c"># eat def.</span>
      <span class="n">proto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParsePrototype</span><span class="p">()</span>
      <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseExpression</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">FunctionNode</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>

   <span class="c"># toplevelexpr ::= expression</span>
   <span class="k">def</span> <span class="nf">ParseTopLevelExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">proto</span> <span class="o">=</span> <span class="n">PrototypeNode</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="p">[])</span>
      <span class="k">return</span> <span class="n">FunctionNode</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseExpression</span><span class="p">())</span>

   <span class="c"># external ::= &#39;extern&#39; prototype</span>
   <span class="k">def</span> <span class="nf">ParseExtern</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># eat extern.</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParsePrototype</span><span class="p">()</span>

   <span class="c"># Top-Level parsing</span>
   <span class="k">def</span> <span class="nf">HandleDefinition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseDefinition</span><span class="p">,</span> <span class="s">&#39;Read a function definition:&#39;</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">HandleExtern</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ParseExtern</span><span class="p">,</span> <span class="s">&#39;Read an extern:&#39;</span><span class="p">)</span>

   <span class="k">def</span> <span class="nf">HandleTopLevelExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ParseTopLevelExpr</span><span class="p">()</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
         <span class="n">result</span> <span class="o">=</span> <span class="n">g_llvm_executor</span><span class="o">.</span><span class="n">run_function</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="p">[])</span>
         <span class="k">print</span> <span class="s">&#39;Evaluated to:&#39;</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">as_real</span><span class="p">(</span><span class="n">Type</span><span class="o">.</span><span class="n">double</span><span class="p">())</span>
      <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
         <span class="k">print</span> <span class="s">&#39;Error:&#39;</span><span class="p">,</span> <span class="n">e</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># Skip for error recovery.</span>
         <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

   <span class="k">def</span> <span class="nf">Handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="k">print</span> <span class="n">message</span><span class="p">,</span> <span class="n">function</span><span class="p">()</span><span class="o">.</span><span class="n">CodeGen</span><span class="p">()</span>
      <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
         <span class="k">print</span> <span class="s">&#39;Error:&#39;</span><span class="p">,</span> <span class="n">e</span>
         <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>  <span class="c"># Skip for error recovery.</span>
         <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="main-driver-code">
<h3>4.5.5. Main driver code.<a class="headerlink" href="#main-driver-code" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
   <span class="c"># Set up the optimizer pipeline. Start with registering info about how the</span>
   <span class="c"># target lays out data structures.</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g_llvm_executor</span><span class="o">.</span><span class="n">target_data</span><span class="p">)</span>
   <span class="c"># Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PASS_INSTRUCTION_COMBINING</span><span class="p">)</span>
   <span class="c"># Reassociate expressions.</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PASS_REASSOCIATE</span><span class="p">)</span>
   <span class="c"># Eliminate Common SubExpressions.</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PASS_GVN</span><span class="p">)</span>
   <span class="c"># Simplify the control flow graph (deleting unreachable blocks, etc).</span>
   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PASS_CFG_SIMPLIFICATION</span><span class="p">)</span>

   <span class="n">g_llvm_pass_manager</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

   <span class="c"># Install standard binary operators.</span>
   <span class="c"># 1 is lowest possible precedence. 40 is the highest.</span>
   <span class="n">operator_precedence</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s">&#39;&lt;&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
      <span class="s">&#39;+&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
      <span class="s">&#39;-&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
      <span class="s">&#39;*&#39;</span><span class="p">:</span> <span class="mi">40</span>
   <span class="p">}</span>

   <span class="c"># Run the main &quot;interpreter loop&quot;.</span>
   <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
      <span class="k">print</span> <span class="s">&#39;ready&gt;&#39;</span><span class="p">,</span>
      <span class="k">try</span><span class="p">:</span>
         <span class="n">raw</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">()</span>
      <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
         <span class="k">break</span>

      <span class="n">parser</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">(</span><span class="n">Tokenize</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">operator_precedence</span><span class="p">)</span>
      <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
         <span class="c"># top ::= definition | external | expression | EOF</span>
         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">EOFToken</span><span class="p">):</span>
            <span class="k">break</span>
         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">DefToken</span><span class="p">):</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">HandleDefinition</span><span class="p">()</span>
         <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="n">ExternToken</span><span class="p">):</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">HandleExtern</span><span class="p">()</span>
         <span class="k">else</span><span class="p">:</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">HandleTopLevelExpression</span><span class="p">()</span>

   <span class="c"># Print out all of the generated code.</span>
   <span class="k">print</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">g_llvm_module</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
   <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4. Chapter 4: Adding JIT and Optimizer Support</a><ul>
<li><a class="reference internal" href="#introduction">4.1. Introduction</a></li>
<li><a class="reference internal" href="#trivial-constant-folding">4.2. Trivial Constant Folding</a></li>
<li><a class="reference internal" href="#llvm-optimization-passes">4.3. LLVM Optimization Passes</a></li>
<li><a class="reference internal" href="#adding-a-jit-compiler">4.4. Adding a JIT Compiler</a></li>
<li><a class="reference internal" href="#full-code-listing">4.5. Full Code Listing</a><ul>
<li><a class="reference internal" href="#globals">4.5.1. Globals</a></li>
<li><a class="reference internal" href="#lexer">4.5.2. Lexer</a></li>
<li><a class="reference internal" href="#abstract-syntax-tree-aka-parse-tree">4.5.3. Abstract Syntax Tree (aka Parse Tree)</a></li>
<li><a class="reference internal" href="#parser">4.5.4. Parser</a></li>
<li><a class="reference internal" href="#main-driver-code">4.5.5. Main driver code.</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="PythonLangImpl3.html"
                        title="previous chapter">3. Chapter 3: Code generation to LLVM IR</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="PythonLangImpl5.html"
                        title="next chapter">5. Chapter 5: Extending the Language: Control Flow</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/doc/kaleidoscope/PythonLangImpl4.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl5.html" title="5. Chapter 5: Extending the Language: Control Flow"
             >next</a> |</li>
        <li class="right" >
          <a href="PythonLangImpl3.html" title="3. Chapter 3: Code generation to LLVM IR"
             >previous</a> |</li>
        <li><a href="../../index.html">llvmpy 0.9.0 documentation</a> &raquo;</li>
          <li><a href="../examples.html" >Examples and LLVM Tutorials</a> &raquo;</li>
          <li><a href="index.html" >Kaleidoscope</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Mahadevan R (2008-2010), Continuum Analytics (2012).
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>